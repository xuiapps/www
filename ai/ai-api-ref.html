<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Xui API Reference for AI Consumption | XUI APPS </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Xui API Reference for AI Consumption | XUI APPS ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/xuiapps/code/blob/main/www/ai/ai-api-ref.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="XUI APPS">
            XUI APPS
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="xui-api-reference-for-ai-consumption">Xui API Reference for AI Consumption</h1>

<p><em>Generated on 2025-04-26 18:41 UTC</em></p>
<p>This document is an automatically generated API reference extracted directly from the Xui source code.
It is optimized for AI models to efficiently understand the framework.</p>
<h2 id="assembly-core">Assembly: Core</h2>
<h3 id="abstractapplicationcs">Abstract/Application.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Actual;

namespace Xui.Core.Abstract;
/// &lt;summary&gt;
/// Represents an abstract base class for Xui applications.
/// This class is paired at runtime with a platform-specific counterpart,
/// which delegates to actual system APIs on macOS, Windows, Android, etc.
///
/// Users should subclass &lt;see cref = &quot;Application&quot;/&gt;, override the &lt;see cref = &quot;Start&quot;/&gt; method,
/// and call &lt;see cref = &quot;Run&quot;/&gt; to launch the application.
/// &lt;/summary&gt;
public abstract class Application
{
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;Application&quot;/&gt; class.
    /// &lt;/summary&gt;
    public Application()
    {
    }

    /// &lt;summary&gt;
    /// Starts the main application loop by delegating to the platform-specific run loop.
    /// This method may block until the application exits,
    /// or may return immediately if the platform bootstraps a runtime loop before instantiating the app delegate.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The application’s exit code.&lt;/returns&gt;
    public int Run()
    {
    }

    /// &lt;summary&gt;
    /// Called by the runtime after initialization.
    /// Override this method to set up application state and display the initial UI.
    /// &lt;/summary&gt;
    public abstract void Start();
}
</code></pre>
<h3 id="abstracteventsdeletebackwardseventrefcs">Abstract/Events/DeleteBackwardsEventRef.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event requesting deletion of content
/// positioned logically before the caret or selection range.
/// Typically triggered by a &quot;Backspace&quot; key press or an equivalent gesture.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event originates from the &lt;c&gt;Actual&lt;/c&gt; window layer and is forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; window for dispatching through the view hierarchy.
/// It is intended to be routed to the appropriate focused or editable view.
/// &lt;/remarks&gt;
public ref struct DeleteBackwardsEventRef
{
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;DeleteBackwardsEventRef&quot;/&gt; struct.
    /// &lt;/summary&gt;
    public DeleteBackwardsEventRef()
    {
    }
}
</code></pre>
<h3 id="abstracteventsframeeventrefcs">Abstract/Events/FrameEventRef.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level event dispatched once per frame,
/// providing timing information used for driving animations and visual updates.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is emitted from the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; window, typically during the animation phase
/// of the UI lifecycle. It provides both the previous and next frame times,
/// along with the time delta between them. Consumers can use this data
/// to advance animations or perform time-based layout updates.
/// &lt;/remarks&gt;
public ref struct FrameEventRef
{
    /// &lt;summary&gt;
    /// The timestamp of the previous frame.
    /// &lt;/summary&gt;
    public TimeSpan Previous;
    /// &lt;summary&gt;
    /// The timestamp of the upcoming frame.
    /// &lt;/summary&gt;
    public TimeSpan Next;
    /// &lt;summary&gt;
    /// The time elapsed between the previous and next frames.
    /// &lt;/summary&gt;
    public TimeSpan Delta;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;FrameEventRef&quot;/&gt; struct
    /// with the given previous and next frame timestamps.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;previous&quot;&gt;The timestamp of the previous frame.&lt;/param&gt;
    /// &lt;param name = &quot;next&quot;&gt;The timestamp of the upcoming frame.&lt;/param&gt;
    public FrameEventRef(TimeSpan previous, TimeSpan next)
    {
    }
}
</code></pre>
<h3 id="abstracteventsinserttexteventrefcs">Abstract/Events/InsertTextEventRef.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event requesting insertion of text
/// at the current caret or selection position.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event originates from the &lt;c&gt;Actual&lt;/c&gt; window and is forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for dispatch through the view hierarchy.
/// It is typically triggered by user input such as typing characters,
/// pasting from the clipboard, or text input from IMEs.
/// &lt;/remarks&gt;
public ref struct InsertTextEventRef
{
    /// &lt;summary&gt;
    /// The text to be inserted into the current input context.
    /// &lt;/summary&gt;
    public readonly string Text;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;InsertTextEventRef&quot;/&gt; struct
    /// with the specified text to insert.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;text&quot;&gt;The string of text to be inserted.&lt;/param&gt;
    public InsertTextEventRef(string text)
    {
    }
}
</code></pre>
<h3 id="abstracteventsmousebuttoncs">Abstract/Events/MouseButton.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Identifies a specific mouse button involved in a pointer event.
/// &lt;/summary&gt;
public enum MouseButton
{
    /// &lt;summary&gt;
    /// The left mouse button, typically used for primary actions like selection or dragging.
    /// &lt;/summary&gt;
    Left,
    /// &lt;summary&gt;
    /// The right mouse button, typically used for context menus or alternate actions.
    /// &lt;/summary&gt;
    Right,
    /// &lt;summary&gt;
    /// Any other mouse button, such as middle-click or additional buttons on advanced mice.
    /// &lt;/summary&gt;
    Other
}
</code></pre>
<h3 id="abstracteventsmousedowneventrefcs">Abstract/Events/MouseDownEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event indicating that a mouse button
/// was pressed at a given position.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for routing through the view hierarchy.
/// It may be used to initiate focus, dragging, selection, or other pointer interactions.
/// &lt;/remarks&gt;
public ref struct MouseDownEventRef
{
    /// &lt;summary&gt;
    /// The position of the mouse pointer at the time of the event,
    /// in logical window coordinates.
    /// &lt;/summary&gt;
    public Point Position;
    /// &lt;summary&gt;
    /// The mouse button that was pressed.
    /// &lt;/summary&gt;
    public MouseButton Button;
}
</code></pre>
<h3 id="abstracteventsmousemoveeventrefcs">Abstract/Events/MouseMoveEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event indicating that the mouse pointer
/// has moved to a new position.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for routing through the view hierarchy.
/// It is typically used to trigger hover effects, cursor updates,
/// or to track dragging or gesture movement.
/// &lt;/remarks&gt;
public ref struct MouseMoveEventRef
{
    /// &lt;summary&gt;
    /// The current position of the mouse pointer in logical window coordinates.
    /// &lt;/summary&gt;
    public Point Position;
}
</code></pre>
<h3 id="abstracteventsmouseupeventrefcs">Abstract/Events/MouseUpEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event indicating that a mouse button
/// was released at a given position.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for routing through the view hierarchy.
/// It is typically used to complete interactions such as clicks, drags,
/// or other pointer-driven gestures.
/// &lt;/remarks&gt;
public ref struct MouseUpEventRef
{
    /// &lt;summary&gt;
    /// The position of the mouse pointer at the time of the event,
    /// in logical window coordinates.
    /// &lt;/summary&gt;
    public Point Position;
    /// &lt;summary&gt;
    /// The mouse button that was released.
    /// &lt;/summary&gt;
    public MouseButton Button;
}
</code></pre>
<h3 id="abstracteventsrendereventrefcs">Abstract/Events/RenderEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level render event dispatched after a timing frame,
/// indicating that views should perform layout and rendering operations within a given region.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event follows a &lt;see cref = &quot;FrameEventRef&quot;/&gt; and marks the phase during which
/// views are expected to perform their &lt;c&gt;Measure&lt;/c&gt;, &lt;c&gt;Arrange&lt;/c&gt;, and &lt;c&gt;Render&lt;/c&gt; passes.
/// It is emitted by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded to the &lt;c&gt;Abstract&lt;/c&gt; layer.
/// &lt;/remarks&gt;
public ref struct RenderEventRef
{
    /// &lt;summary&gt;
    /// The region of the screen or surface that should be re-rendered.
    /// &lt;/summary&gt;
    public Rect Rect;
    /// &lt;summary&gt;
    /// Timing information associated with this frame, typically used for animations.
    /// &lt;/summary&gt;
    public FrameEventRef Frame;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;RenderEventRef&quot;/&gt; struct
    /// with the given invalidation region and frame timing data.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The region to be rendered.&lt;/param&gt;
    /// &lt;param name = &quot;frame&quot;&gt;The timing information for this frame.&lt;/param&gt;
    public RenderEventRef(Rect rect, FrameEventRef frame)
    {
    }
}
</code></pre>
<h3 id="abstracteventsscrollwheeleventrefcs">Abstract/Events/ScrollWheelEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event generated by a scroll wheel or trackpad gesture,
/// indicating a change in scroll position.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for routing through the view hierarchy.
/// It may be used to scroll content, zoom views, or trigger kinetic effects,
/// depending on platform and modifier keys.
/// &lt;/remarks&gt;
public ref struct ScrollWheelEventRef
{
    /// &lt;summary&gt;
    /// The scroll delta, typically measured in logical units per axis.
    /// Positive Y values usually indicate upward scrolling.
    /// &lt;/summary&gt;
    public Vector Delta;
}
</code></pre>
<h3 id="abstracteventstouchcs">Abstract/Events/Touch.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a single touch point within a multi-touch input event.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This structure contains identifying and positional data for a specific finger
/// or contact point on a touch surface. Multiple &lt;see cref = &quot;Touch&quot;/&gt; instances may be
/// reported in a single event when handling gestures or complex touch interactions.
/// &lt;/remarks&gt;
public struct Touch
{
    /// &lt;summary&gt;
    /// A unique index identifying this touch point during its lifetime.
    /// Typically assigned by the platform and reused after release.
    /// &lt;/summary&gt;
    public long Index;
    /// &lt;summary&gt;
    /// The current position of the touch in logical window coordinates.
    /// &lt;/summary&gt;
    public Point Position;
    /// &lt;summary&gt;
    /// The estimated contact radius of the touch, in logical units.
    /// Used for gesture recognition or pressure emulation.
    /// &lt;/summary&gt;
    public nfloat Radius;
    /// &lt;summary&gt;
    /// The current phase of the touch (e.g., began, moved, ended).
    /// &lt;/summary&gt;
    public TouchPhase Phase;
}
</code></pre>
<h3 id="abstracteventstoucheventrefcs">Abstract/Events/TouchEventRef.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level input event containing one or more touch points,
/// typically originating from a touchscreen or trackpad gesture.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched by the &lt;c&gt;Actual&lt;/c&gt; window and forwarded
/// to the &lt;c&gt;Abstract&lt;/c&gt; layer for routing through the view hierarchy.
/// It includes all active touch points for the current frame, allowing
/// gesture recognition, hit testing, and view interaction logic.
/// &lt;/remarks&gt;
public ref struct TouchEventRef
{
    /// &lt;summary&gt;
    /// A span of all current touch points involved in this event.
    /// &lt;/summary&gt;
    public readonly ReadOnlySpan&lt;Touch&gt; Touches;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;TouchEventRef&quot;/&gt; struct
    /// with the provided set of touch points.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;touches&quot;&gt;A span of active touch data.&lt;/param&gt;
    public TouchEventRef(ReadOnlySpan&lt;Touch&gt; touches)
    {
    }
}
</code></pre>
<h3 id="abstracteventstouchphasecs">Abstract/Events/TouchPhase.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Describes the phase of an individual touch point during a touch event.
/// &lt;/summary&gt;
public enum TouchPhase
{
    /// &lt;summary&gt;
    /// The touch has just started (finger or stylus contacted the surface).
    /// &lt;/summary&gt;
    Start,
    /// &lt;summary&gt;
    /// The touch is actively moving across the surface.
    /// &lt;/summary&gt;
    Move,
    /// &lt;summary&gt;
    /// The touch has ended (finger or stylus lifted off the surface).
    /// &lt;/summary&gt;
    End
}
</code></pre>
<h3 id="abstracteventswindowhittesteventrefcs">Abstract/Events/WindowHitTestEventRef.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract.Events;
/// &lt;summary&gt;
/// Represents a platform-level hit test event that allows the application
/// to define how a point within a custom window frame should be interpreted
/// (e.g., as a draggable title bar, resize border, or transparent region).
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This event is dispatched when the user interacts with the non-client area
/// of a custom-framed window (such as the emulator window or a styled installer).
/// It is primarily used on platforms like Windows that support fine-grained
/// window frame interaction via hit testing.
///
/// On macOS and other platforms where native support is unavailable,
/// this event may be ignored or implemented through custom code.
/// &lt;/remarks&gt;
public ref struct WindowHitTestEventRef
{
    /// &lt;summary&gt;
    /// The location of the hit test, in logical window coordinates.
    /// &lt;/summary&gt;
    public Point Point;
    /// &lt;summary&gt;
    /// The bounds of the entire window, in logical coordinates.
    /// This may be used to determine edge proximity for resizing logic.
    /// &lt;/summary&gt;
    public Rect Window;
    /// &lt;summary&gt;
    /// The result of the hit test, set by the application to control
    /// how the system should interpret the hit location.
    /// &lt;/summary&gt;
    public WindowArea Area;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;WindowHitTestEventRef&quot;/&gt; struct.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;point&quot;&gt;The location of the pointer input.&lt;/param&gt;
    /// &lt;param name = &quot;window&quot;&gt;The bounds of the target window.&lt;/param&gt;
    public WindowHitTestEventRef(Point point, Rect window)
    {
    }

    /// &lt;summary&gt;
    /// Describes the purpose or function of a region within a window.
    /// &lt;/summary&gt;
    public enum WindowArea : uint
    {
        /// &lt;summary&gt;
        /// The area is unspecified; the platform should handle it normally.
        /// &lt;/summary&gt;
        Default = 0,
        /// &lt;summary&gt;
        /// The area is transparent to hit testing and should not trigger drag or resize.
        /// &lt;/summary&gt;
        Transparent,
        /// &lt;summary&gt;
        /// The area represents the client region of the window (normal content).
        /// &lt;/summary&gt;
        Client,
        /// &lt;summary&gt;
        /// The area represents a draggable title bar region.
        /// &lt;/summary&gt;
        Title,
        /// &lt;summary&gt;Top-left resize corner.&lt;/summary&gt;
        BorderTopLeft,
        /// &lt;summary&gt;Top edge resize border.&lt;/summary&gt;
        BorderTop,
        /// &lt;summary&gt;Top-right resize corner.&lt;/summary&gt;
        BorderTopRight,
        /// &lt;summary&gt;Right edge resize border.&lt;/summary&gt;
        BorderRight,
        /// &lt;summary&gt;Bottom-right resize corner.&lt;/summary&gt;
        BorderBottomRight,
        /// &lt;summary&gt;Bottom edge resize border.&lt;/summary&gt;
        BorderBottom,
        /// &lt;summary&gt;Bottom-left resize corner.&lt;/summary&gt;
        BorderBottomLeft,
        /// &lt;summary&gt;Left edge resize border.&lt;/summary&gt;
        BorderLeft
    }
}
</code></pre>
<h3 id="abstracthotreloadcs">Abstract/HotReload.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Actual;

[assembly: System.Reflection.Metadata.MetadataUpdateHandler(typeof(Xui.Core.Abstract.HotReload))]
namespace Xui.Core.Abstract;
/// &lt;summary&gt;
/// Internal integration point for .NET's MetadataUpdateHandler, enabling partial support
/// for Hot Reload during development. This is not a stable API and should not be used
/// by application developers.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This type is invoked automatically by the runtime when types are updated via
/// Edit and Continue or Hot Reload. However, Hot Reload support in Xui is limited,
/// and application developers should rely on full rebuilds for consistent behavior.
///
/// The current implementation simply invalidates open windows and clears transient caches,
/// without attempting to rehydrate or diff application state.
/// &lt;/remarks&gt;
public static class HotReload
{
    /// &lt;summary&gt;
    /// Called by the runtime to clear any cached data after a hot reload.
    /// Not intended for use by application developers.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;updatedTypes&quot;&gt;The list of updated types, if available.&lt;/param&gt;
    public static void ClearCache(Type[]? updatedTypes)
    {
    }

    /// &lt;summary&gt;
    /// Posts a request to the main UI dispatcher to refresh application state.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;updatedTypes&quot;&gt;The list of updated types, if available.&lt;/param&gt;
    public static void UpdateApplication(Type[]? updatedTypes)
    {
    }

    /// &lt;summary&gt;
    /// Performs a synchronous application update on the main thread.
    /// This currently forces all open windows to re-render.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;updatedTypes&quot;&gt;The list of updated types, if available.&lt;/param&gt;
    public static void MainThreadUpdateApplication(Type[]? updatedTypes)
    {
    }
}
</code></pre>
<h3 id="abstractiwindowcs">Abstract/IWindow.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Abstract.Events;
using Xui.Core.Math2D;

namespace Xui.Core.Abstract;
/// &lt;summary&gt;
/// Defines the abstract interface for a platform window in Xui.
/// This surface hosts rendering, input handling, and layout updates.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Implementations of this interface bridge platform-specific &lt;c&gt;Actual&lt;/c&gt; windowing
/// with the framework’s abstract layer. It is used both for physical windows (e.g. desktop apps)
/// and virtual windows (e.g. emulator windows).
/// &lt;/remarks&gt;
public partial interface IWindow
{
    /// &lt;summary&gt;
    /// Gets or sets the total visible area of the window, including content that may
    /// be obscured by hardware cutouts, rounded corners, or system UI overlays.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Used by the layout system to determine the full available size.
    /// &lt;/remarks&gt;
    public Rect DisplayArea { get; set; }
    /// &lt;summary&gt;
    /// Gets or sets the &quot;safe&quot; area of the window, excluding obstructions like notches
    /// or status bars. Important UI elements should be placed within this area.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Especially relevant on mobile devices and in emulator scenarios.
    /// &lt;/remarks&gt;
    public Rect SafeArea { get; set; }

    /// &lt;summary&gt;
    /// Invoked when the window is closed and cleanup should occur.
    /// &lt;/summary&gt;
    void Closed();
    /// &lt;summary&gt;
    /// Invoked before the window closes. Returning &lt;c&gt;false&lt;/c&gt; can cancel the closure.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the window may close; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
    bool Closing();
    /// &lt;summary&gt;
    /// Invoked once per frame to propagate animation timing information.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;animationFrame&quot;&gt;Timing details for the current animation frame.&lt;/param&gt;
    void OnAnimationFrame(ref FrameEventRef animationFrame);
    /// &lt;summary&gt;
    /// Invoked when the mouse is moved within the window.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;evRef&quot;&gt;The mouse movement event data.&lt;/param&gt;
    void OnMouseMove(ref MouseMoveEventRef evRef);
    /// &lt;summary&gt;
    /// Invoked when a mouse button is pressed within the window.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;evRef&quot;&gt;The mouse down event data.&lt;/param&gt;
    void OnMouseDown(ref MouseDownEventRef evRef);
    /// &lt;summary&gt;
    /// Invoked when a mouse button is released within the window.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;evRef&quot;&gt;The mouse up event data.&lt;/param&gt;
    void OnMouseUp(ref MouseUpEventRef evRef);
    /// &lt;summary&gt;
    /// Invoked when the scroll wheel is used within the window.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;evRef&quot;&gt;The scroll wheel event data.&lt;/param&gt;
    void OnScrollWheel(ref ScrollWheelEventRef evRef);
    /// &lt;summary&gt;
    /// Invoked when touch input occurs within the window.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;touchEventRef&quot;&gt;The touch event data.&lt;/param&gt;
    void OnTouch(ref TouchEventRef touchEventRef);
    /// &lt;summary&gt;
    /// Invoked during the render phase of the UI lifecycle.
    /// Responsible for triggering layout and visual updates.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;render&quot;&gt;The render event data, including target rect and frame info.&lt;/param&gt;
    void Render(ref RenderEventRef render);
    /// &lt;summary&gt;
    /// Invoked when the system requests a hit test for window interaction.
    /// Allows the app to indicate whether a region is draggable, resizable, etc.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;evRef&quot;&gt;The hit test event containing pointer position and window bounds.&lt;/param&gt;
    void WindowHitTest(ref WindowHitTestEventRef evRef);
}
</code></pre>
<h3 id="abstractiwindowidesktopstylecs">Abstract/IWindow.IDesktopStyle.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Abstract;
public partial interface IWindow
{
    /// &lt;summary&gt;
    /// Provides optional desktop-specific window styling hints for platforms
    /// that support multiple top-level windows (e.g., Windows, macOS, Linux).
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// On mobile platforms, applications typically run in a single full-screen window,
    /// and this interface has no effect. On desktop, implementing this interface allows
    /// apps to influence window chrome, border visibility, and initial sizing.
    /// &lt;/remarks&gt;
    public interface IDesktopStyle
    {
        /// &lt;summary&gt;
        /// If &lt;c&gt;true&lt;/c&gt;, the window will be created without a system title bar or border.
        /// The entire surface will be treated as a client area, while still maintaining
        /// standard desktop window behaviors (e.g., close/minimize buttons).
        /// &lt;/summary&gt;
        public bool Chromeless
        {
            get
            {
            }
        }

        /// &lt;summary&gt;
        /// Optional startup size hint for the window.
        /// If &lt;c&gt;null&lt;/c&gt;, the platform will decide the initial size.
        /// &lt;/summary&gt;
        public Size? StartupSize
        {
            get
            {
            }
        }
    }
}
</code></pre>
<h3 id="abstractiwindowisoftkeyboardcs">Abstract/IWindow.ISoftKeyboard.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Abstract.Events;
using Xui.Core.Math2D;

namespace Xui.Core.Abstract;
public partial interface IWindow
{
    /// &lt;summary&gt;
    /// Represents a handler for software keyboard input.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This interface allows focused views to receive input from the system's software keyboard,
    /// typically used on mobile platforms and the emulator. It handles character insertion
    /// and backward deletion commands.
    ///
    /// This is not meant to expose full IME or keyboard layout logic—just basic input dispatch.
    /// &lt;/remarks&gt;
    public interface ISoftKeyboard
    {
        /// &lt;summary&gt;
        /// Requests insertion of one or more characters into the current input context.
        /// &lt;/summary&gt;
        /// &lt;param name = &quot;eventRef&quot;&gt;The input event containing the text to insert.&lt;/param&gt;
        public void InsertText(ref InsertTextEventRef eventRef);
        /// &lt;summary&gt;
        /// Requests deletion of content preceding the caret or selection.
        /// &lt;/summary&gt;
        /// &lt;param name = &quot;eventRef&quot;&gt;The input event representing a backspace action.&lt;/param&gt;
        public void DeleteBackwards(ref DeleteBackwardsEventRef eventRef);
    }
}
</code></pre>
<h3 id="abstractwindowcs">Abstract/Window.cs</h3>
<pre><code class="lang-csharp">using System.Collections.ObjectModel;
using Xui.Core.Abstract.Events;
using Xui.Core.Actual;
using Xui.Core.Math2D;
using Xui.Core.UI;

namespace Xui.Core.Abstract;
/// &lt;summary&gt;
/// Represents an abstract cross-platform application window in Xui.
/// Handles input, rendering, layout, and software keyboard integration.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This class connects the abstract UI framework with the underlying platform window,
/// acting as a root container for layout and visual composition. Subclasses may override
/// specific input or rendering behaviors as needed.
/// &lt;/remarks&gt;
public abstract class Window : Abstract.IWindow, Abstract.IWindow.ISoftKeyboard
{
    private static IList&lt;Window&gt; openWindows = new List&lt;Window&gt;();
    /// &lt;summary&gt;
    /// Gets a read-only list of all currently open Xui windows.
    /// &lt;/summary&gt;
    public static IReadOnlyList&lt;Window&gt; OpenWindows = new ReadOnlyCollection&lt;Window&gt;(openWindows);
    /// &lt;summary&gt;
    /// Gets the underlying platform-specific window instance.
    /// &lt;/summary&gt;
    public Actual.IWindow Actual { get; }
    /// &lt;inheritdoc/&gt;
    public virtual Rect DisplayArea { get; set; }
    /// &lt;inheritdoc/&gt;
    public virtual Rect SafeArea { get; set; }
    /// &lt;summary&gt;
    /// The root view of the window's content hierarchy.
    /// &lt;/summary&gt;
    public virtual View? Content { get; set; }

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;Window&quot;/&gt; class.
    /// This creates the backing platform window.
    /// &lt;/summary&gt;
    public Window()
    {
    }

    /// &lt;summary&gt;
    /// Gets or sets the window title (where supported by the platform).
    /// &lt;/summary&gt;
    public string Title
    {
        get
        {
        }

        set
        {
        }
    }

    /// &lt;summary&gt;
    /// Requests that the soft keyboard be shown or hidden (on supported platforms).
    /// &lt;/summary&gt;
    public bool RequireKeyboard
    {
        get
        {
        }

        set
        {
        }
    }

    /// &lt;summary&gt;
    /// Makes the window visible and adds it to the list of open windows.
    /// &lt;/summary&gt;
    public void Show()
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void Render(ref RenderEventRef renderEventRef)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void WindowHitTest(ref WindowHitTestEventRef evRef)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual bool Closing()
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void Closed()
    {
    }

    /// &lt;summary&gt;
    /// Creates the platform-specific window for this abstract window.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The platform implementation of &lt;see cref = &quot;Actual.IWindow&quot;/&gt;.&lt;/returns&gt;
    protected virtual Actual.IWindow CreateActualWindow()
    {
    }

    /// &lt;summary&gt;
    /// Requests a visual invalidation/redraw of this window.
    /// &lt;/summary&gt;
    public virtual void Invalidate()
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnMouseDown(ref MouseDownEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnMouseMove(ref MouseMoveEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnMouseUp(ref MouseUpEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnScrollWheel(ref ScrollWheelEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnTouch(ref TouchEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void OnAnimationFrame(ref FrameEventRef e)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void InsertText(ref InsertTextEventRef eventRef)
    {
    }

    /// &lt;inheritdoc/&gt;
    public virtual void DeleteBackwards(ref DeleteBackwardsEventRef eventRef)
    {
    }
}
</code></pre>
<h3 id="actualidispatchercs">Actual/IDispatcher.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Actual;
/// &lt;summary&gt;
/// Represents a platform-specific dispatcher for marshaling callbacks onto the main UI thread.
/// Used by the Xui runtime to ensure thread-safe execution of UI logic.
///
/// Each platform must provide an implementation that posts callbacks to the appropriate runloop or UI thread.
/// &lt;/summary&gt;
public interface IDispatcher
{
    /// &lt;summary&gt;
    /// Posts the specified callback to be executed on the dispatcher's thread (typically the UI thread).
    /// Use this method when calling from a background thread and needing to safely transition
    /// to the main thread for UI updates or layout work.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;callback&quot;&gt;The action to execute on the dispatcher's thread.&lt;/param&gt;
    void Post(Action callback);
}
</code></pre>
<h3 id="actualirunloopcs">Actual/IRunLoop.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Actual;
/// &lt;summary&gt;
/// Represents a platform-specific run loop responsible for driving the application's lifecycle.
/// Each platform must provide an implementation that enters the appropriate system event loop
/// and continues running until the application exits.
///
/// The Xui runtime uses this interface to abstract over platform differences in event dispatch and app execution.
/// &lt;/summary&gt;
public interface IRunLoop
{
    /// &lt;summary&gt;
    /// Starts the main run loop for the application.
    /// This method may block until the application terminates or exits naturally.
    /// On platforms with built-in UI event loops (e.g., iOS, Android),
    /// this method may return immediately after bootstrapping the application delegate.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The application’s exit code.&lt;/returns&gt;
    int Run();
}
</code></pre>
<h3 id="actualiruntimecs">Actual/IRuntime.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Canvas;

namespace Xui.Core.Actual;
/// &lt;summary&gt;
/// Provides a platform-specific implementation of the Xui runtime,
/// responsible for creating and connecting abstract application components to their actual counterparts.
///
/// This interface acts as a bridge between the platform-independent core and the underlying OS-specific APIs
/// (e.g., Win32, Cocoa, UIKit), enabling rendering, windowing, and event dispatch.
/// &lt;/summary&gt;
public interface IRuntime
{
    /// &lt;summary&gt;
    /// Gets the global drawing context for the current platform.
    /// This typically wraps a native graphics context such as Direct2D (Windows) or CGContext (macOS),
    /// and serves as the entry point for rendering operations.
    /// &lt;/summary&gt;
    IContext DrawingContext { get; }

    /// &lt;summary&gt;
    /// Gets the main thread dispatcher for scheduling UI work.
    /// Used to marshal execution onto the main thread for layout, input, and rendering.
    /// &lt;/summary&gt;
    IDispatcher MainDispatcher { get; }

    /// &lt;summary&gt;
    /// Creates a platform-specific window that is bound to the given abstract window definition.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;windowAbstract&quot;&gt;The abstract window definition provided by user code.&lt;/param&gt;
    /// &lt;returns&gt;A concrete window implementation for the current platform.&lt;/returns&gt;
    Actual.IWindow CreateWindow(Abstract.IWindow windowAbstract);
    /// &lt;summary&gt;
    /// Creates a platform-specific run loop associated with the given abstract application.
    /// The returned run loop is responsible for managing the application's execution lifecycle.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;applicationAbstract&quot;&gt;The abstract application instance defined by user code.&lt;/param&gt;
    /// &lt;returns&gt;A platform-specific run loop instance.&lt;/returns&gt;
    IRunLoop CreateRunloop(Abstract.Application applicationAbstract);
}
</code></pre>
<h3 id="actualiwindowcs">Actual/IWindow.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Actual;
/// &lt;summary&gt;
/// Represents a platform-specific window implementation used by the Xui runtime.
/// Each platform (e.g., Windows, macOS, iOS) must provide an implementation of this interface
/// to manage window lifecycle, rendering, and input.
///
/// This interface is typically paired with an abstract window in the Xui framework,
/// and is not used directly by application developers.
/// &lt;/summary&gt;
public interface IWindow
{
    /// &lt;summary&gt;
    /// Gets or sets the window title, where supported by the platform (e.g., desktop).
    /// &lt;/summary&gt;
    string Title { get; set; }

    /// &lt;summary&gt;
    /// Displays the window to the user. This may include making it visible, entering the main loop,
    /// or attaching it to the application’s view hierarchy, depending on the platform.
    /// &lt;/summary&gt;
    void Show();
    /// &lt;summary&gt;
    /// Requests a redraw of the window surface.
    /// The platform should trigger a paint or render callback as soon as possible.
    /// &lt;/summary&gt;
    void Invalidate();
    /// &lt;summary&gt;
    /// Gets or sets whether the window currently requires keyboard input focus.
    /// Platforms may use this to show or hide on-screen keyboards.
    /// &lt;/summary&gt;
    bool RequireKeyboard { get; set; }
}
</code></pre>
<h3 id="actualruntimecs">Actual/Runtime.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Actual;
using Xui.Core.Canvas;

namespace Xui.Core.Actual;
/// &lt;summary&gt;
/// Provides global access to the platform-specific runtime environment for the current Xui application.
/// 
/// The platform must assign &lt;see cref = &quot;Current&quot;/&gt; at startup with a concrete &lt;see cref = &quot;IRuntime&quot;/&gt; implementation,
/// which wires up platform-specific services like rendering, window creation, and dispatching.
/// &lt;/summary&gt;
public static class Runtime
{
    private static IRuntime? current;
    /// &lt;summary&gt;
    /// Gets or sets the current platform runtime instance.
    /// This must be initialized at application startup by platform bootstrap code.
    /// &lt;/summary&gt;
    /// &lt;exception cref = &quot;RuntimeNotAvailable&quot;&gt;
    /// Thrown if accessed before the runtime has been initialized.
    /// &lt;/exception&gt;
    public static IRuntime Current
    {
        get
        {
        }

        set
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the global drawing context provided by the current platform runtime, if available.
    /// &lt;/summary&gt;
    public static IContext? DrawingContext
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the main dispatcher for scheduling UI work on the platform's main thread, if available.
    /// &lt;/summary&gt;
    public static IDispatcher? MainDispatcher
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Exception thrown when &lt;see cref = &quot;Current&quot;/&gt; is accessed before it has been initialized.
    /// &lt;/summary&gt;
    public class RuntimeNotAvailable : Exception
    {
        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref = &quot;RuntimeNotAvailable&quot;/&gt; exception
        /// with a helpful diagnostic message.
        /// &lt;/summary&gt;
        public RuntimeNotAvailable() : base(&quot;First thing to do in your app is set Runtime.Current!\nSomehow the execution reached a Runtime.Current call before a runtime was set.&quot;)
        {
        }
    }
}
</code></pre>
<h3 id="animationconstantdecelerationcurvecs">Animation/ConstantDecelerationCurve.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Animation;
/// &lt;summary&gt;
/// Represents a 1D motion curve with constant deceleration (e.g., for scroll or fling).
/// Starts at a given position and velocity, then decelerates linearly to a stop.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This model is commonly used in UI frameworks to simulate natural-feeling scroll behavior.
/// The acceleration is constant and opposite to the direction of motion, resulting in
/// a predictable, smooth slowdown.
/// &lt;/remarks&gt;
public readonly struct ConstantDecelerationCurve
{
    /// &lt;summary&gt;
    /// The time when the motion begins.
    /// &lt;/summary&gt;
    public readonly TimeSpan StartTime;
    /// &lt;summary&gt;
    /// The time when the motion stops (velocity reaches zero).
    /// &lt;/summary&gt;
    public readonly TimeSpan EndTime;
    /// &lt;summary&gt;
    /// The constant acceleration applied during motion, typically negative.
    /// &lt;/summary&gt;
    public readonly nfloat A;
    /// &lt;summary&gt;
    /// The initial velocity at &lt;see cref = &quot;StartTime&quot;/&gt;, in pixels per second.
    /// &lt;/summary&gt;
    public readonly nfloat V0;
    /// &lt;summary&gt;
    /// The initial position at &lt;see cref = &quot;StartTime&quot;/&gt;, in pixels.
    /// &lt;/summary&gt;
    public readonly nfloat P0;
    /// &lt;summary&gt;
    /// Constructs a motion curve with constant deceleration.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startTime&quot;&gt;The time when motion begins.&lt;/param&gt;
    /// &lt;param name = &quot;position&quot;&gt;The initial position at &lt;paramref name = &quot;startTime&quot;/&gt;.&lt;/param&gt;
    /// &lt;param name = &quot;velocity&quot;&gt;The initial velocity in pixels per second.&lt;/param&gt;
    /// &lt;param name = &quot;accelerationMagnitude&quot;&gt;The magnitude of deceleration (must be positive).&lt;/param&gt;
    /// &lt;exception cref = &quot;ArgumentOutOfRangeException&quot;&gt;Thrown if &lt;paramref name = &quot;accelerationMagnitude&quot;/&gt; is not positive.&lt;/exception&gt;
    public ConstantDecelerationCurve(TimeSpan startTime, nfloat position, nfloat velocity, nfloat accelerationMagnitude)
    {
    }

    /// &lt;summary&gt;
    /// The total duration of the motion in seconds.
    /// &lt;/summary&gt;
    public nfloat DurationSeconds
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the position at the specified time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The absolute time at which to evaluate the position.&lt;/param&gt;
    /// &lt;returns&gt;The position in pixels.&lt;/returns&gt;
    public nfloat this[TimeSpan time]
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the velocity at the specified time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The absolute time at which to evaluate the velocity.&lt;/param&gt;
    /// &lt;returns&gt;The velocity in pixels per second.&lt;/returns&gt;
    public nfloat VelocityAt(TimeSpan time)
    {
    }

    private nfloat ClampTime(TimeSpan time)
    {
    }
}
</code></pre>
<h3 id="animationcubicmotioncurvecs">Animation/CubicMotionCurve.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Animation;
/// &lt;summary&gt;
/// Represents a 1D cubic motion curve over time, interpolating both position and velocity.
/// Time is expressed using &lt;see cref = &quot;TimeSpan&quot;/&gt;, and calculations are performed in seconds.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This curve is defined by a cubic polynomial:
/// &lt;c&gt;f(t) = A·t³ + B·t² + C·t + D&lt;/c&gt;, where &lt;c&gt;t&lt;/c&gt; is time in seconds since the global epoch.
/// It supports generation from boundary conditions (position and velocity at both ends),
/// as well as curve continuation with seamless velocity transitions.
/// &lt;/remarks&gt;
public readonly struct CubicMotionCurve
{
    /// &lt;summary&gt;
    /// The time at which the motion curve starts.
    /// &lt;/summary&gt;
    public readonly TimeSpan StartTime;
    /// &lt;summary&gt;
    /// The time at which the motion curve ends.
    /// &lt;/summary&gt;
    public readonly TimeSpan EndTime;
    /// &lt;summary&gt;
    /// The cubic coefficient (multiplied by t³).
    /// &lt;/summary&gt;
    public readonly nfloat A;
    /// &lt;summary&gt;
    /// The quadratic coefficient (multiplied by t²).
    /// &lt;/summary&gt;
    public readonly nfloat B;
    /// &lt;summary&gt;
    /// The linear coefficient (multiplied by t).
    /// &lt;/summary&gt;
    public readonly nfloat C;
    /// &lt;summary&gt;
    /// The constant offset term.
    /// &lt;/summary&gt;
    public readonly nfloat D;
    /// &lt;summary&gt;
    /// Initializes a new cubic motion curve with the given polynomial coefficients and time range.
    /// &lt;/summary&gt;
    public CubicMotionCurve(TimeSpan startTime, TimeSpan endTime, nfloat a, nfloat b, nfloat c, nfloat d)
    {
    }

    /// &lt;summary&gt;
    /// The final position at &lt;see cref = &quot;EndTime&quot;/&gt;.
    /// &lt;/summary&gt;
    public nfloat FinalPosition
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// The duration of the motion curve, in seconds.
    /// &lt;/summary&gt;
    public nfloat DurationSeconds
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Continues the current curve by constructing a new cubic motion curve that
    /// begins where this one leaves off, matching position and velocity, and
    /// interpolating to a new position and velocity over the given time range.
    /// &lt;/summary&gt;
    public CubicMotionCurve ContinueWithBoundaryConditions(TimeSpan startTime, TimeSpan endTime, nfloat endPosition, nfloat endVelocity)
    {
    }

    /// &lt;summary&gt;
    /// Constructs a cubic motion curve that interpolates position and velocity
    /// between two points in time using Hermite interpolation.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startTime&quot;&gt;The curve's start time.&lt;/param&gt;
    /// &lt;param name = &quot;startPosition&quot;&gt;The position at &lt;paramref name = &quot;startTime&quot;/&gt;.&lt;/param&gt;
    /// &lt;param name = &quot;startVelocity&quot;&gt;The velocity at &lt;paramref name = &quot;startTime&quot;/&gt;.&lt;/param&gt;
    /// &lt;param name = &quot;endTime&quot;&gt;The curve's end time.&lt;/param&gt;
    /// &lt;param name = &quot;endPosition&quot;&gt;The position at &lt;paramref name = &quot;endTime&quot;/&gt;.&lt;/param&gt;
    /// &lt;param name = &quot;endVelocity&quot;&gt;The velocity at &lt;paramref name = &quot;endTime&quot;/&gt;.&lt;/param&gt;
    /// &lt;returns&gt;A cubic motion curve satisfying the specified boundary conditions.&lt;/returns&gt;
    public static CubicMotionCurve FromBoundaryConditions(TimeSpan startTime, nfloat startPosition, nfloat startVelocity, TimeSpan endTime, nfloat endPosition, nfloat endVelocity)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the position at the specified time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;An absolute time value.&lt;/param&gt;
    /// &lt;returns&gt;The position at the given time.&lt;/returns&gt;
    public nfloat this[TimeSpan time]
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the velocity at the specified time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;An absolute time value.&lt;/param&gt;
    /// &lt;returns&gt;The velocity at the given time.&lt;/returns&gt;
    public nfloat VelocityAt(TimeSpan time)
    {
    }
}
</code></pre>
<h3 id="animationeasingcs">Animation/Easing.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Animation;
/// &lt;summary&gt;
/// Provides a collection of easing functions and smoothing utilities used in animations.
/// All easing methods are normalized to take a parameter &lt;c&gt;t&lt;/c&gt; in the range [0, 1].
/// &lt;/summary&gt;
public static partial class Easing
{
    private static readonly nfloat c1 = 1.70158f;
    private static readonly nfloat c2 = 1.70158f * 1.525f;
    private static readonly nfloat c4 = (nfloat)(2 * Math.PI) / 3;
    private static readonly nfloat c5 = (nfloat)(2 * Math.PI) / (nfloat)4.5;
    private static readonly nfloat n1 = 7.5625f;
    private static readonly nfloat d1 = 2.75f;
    /// &lt;summary&gt;
    /// Normalizes a value between &lt;paramref name = &quot;min&quot;/&gt; and &lt;paramref name = &quot;max&quot;/&gt; into a [0,1] range.
    /// Returns 0 if &lt;paramref name = &quot;max&quot;/&gt; ≤ &lt;paramref name = &quot;min&quot;/&gt;.
    /// &lt;/summary&gt;
    public static nfloat Normalize(nfloat value, nfloat min, nfloat max)
    {
    }

    /// &lt;summary&gt;
    /// Eases in and out with a sine curve. Smoothest at beginning and end.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutSine(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Accelerates slowly from 0 to 1 with a quadratic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInQuad(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Decelerates smoothly from 1 to 0 with a quadratic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseOutQuad(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Accelerates and decelerates using a quadratic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutQuad(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Accelerates slowly with a cubic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInCubic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Decelerates slowly with a cubic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseOutCubic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Smoothly accelerates and decelerates with a cubic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutCubic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Stronger acceleration from 0 using a quartic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInQuart(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Stronger deceleration to 1 using a quartic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseOutQuart(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Strong acceleration and deceleration using a quartic curve.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutQuart(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Creates an elastic &quot;bounce-in&quot; effect at the beginning of the transition.
    /// &lt;/summary&gt;
    public static nfloat EaseInElastic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Creates an elastic &quot;bounce-out&quot; effect at the end of the transition.
    /// &lt;/summary&gt;
    public static nfloat EaseOutElastic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Combines EaseInElastic and EaseOutElastic for a spring-like bounce effect at both ends.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutElastic(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Eases in with a &quot;backwards&quot; overshoot effect before settling forward.
    /// &lt;/summary&gt;
    public static nfloat EaseInBack(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Eases out with a slight overshoot after reaching the target.
    /// &lt;/summary&gt;
    public static nfloat EaseOutBack(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Eases in and out with a &quot;backwards&quot; overshoot at both ends.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutBack(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Creates a bounce effect as if hitting the ground and bouncing back.
    /// &lt;/summary&gt;
    public static nfloat EaseOutBounce(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Reverses EaseOutBounce to ease in with bounce.
    /// &lt;/summary&gt;
    public static nfloat EaseInBounce(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Eases in and out with a bounce at both ends.
    /// &lt;/summary&gt;
    public static nfloat EaseInOutBounce(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Applies a smoothstep-like easing function that produces smooth transitions with zero first and second derivatives at boundaries.
    /// &lt;/summary&gt;
    public static nfloat SmootherStep(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Smoothly interpolates between two values using a critically damped spring-like function.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;from&quot;&gt;The starting value.&lt;/param&gt;
    /// &lt;param name = &quot;to&quot;&gt;The target value.&lt;/param&gt;
    /// &lt;param name = &quot;velocity&quot;&gt;Reference to current velocity (will be modified).&lt;/param&gt;
    /// &lt;param name = &quot;smoothTime&quot;&gt;Time it takes to reach the target value.&lt;/param&gt;
    /// &lt;param name = &quot;maxSpeed&quot;&gt;Maximum speed during interpolation.&lt;/param&gt;
    /// &lt;param name = &quot;deltaTime&quot;&gt;Elapsed time since the last update.&lt;/param&gt;
    public static nfloat SmoothDamp(nfloat from, nfloat to, ref nfloat velocity, nfloat smoothTime, nfloat maxSpeed, nfloat deltaTime)
    {
    }
}
</code></pre>
<h3 id="animationeasingcubicbeziercs">Animation/Easing.CubicBezier.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Animation;
public static partial class Easing
{
    /// &lt;summary&gt;
    /// Represents a CSS-style cubic Bézier easing curve constrained between (0,0) and (1,1).
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// These curves are used for timing animations and transitions.
    /// The curve always starts at (0,0) and ends at (1,1), and the control points &lt;see cref = &quot;P1&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;
    /// shape the acceleration and deceleration of the animation.
    /// &lt;/remarks&gt;
    public readonly struct CubicBezier
    {
        /// &lt;summary&gt;The first control point (typically near the origin).&lt;/summary&gt;
        public readonly Point P1;
        /// &lt;summary&gt;The second control point (typically near the destination).&lt;/summary&gt;
        public readonly Point P2;
        /// &lt;summary&gt;
        /// Initializes a new CSS-style cubic Bézier easing curve with the given control points.
        /// Assumes endpoints at (0,0) and (1,1).
        /// &lt;/summary&gt;
        public CubicBezier(Point p1, Point p2)
        {
        }

        /// &lt;summary&gt;
        /// Returns the interpolated point on the Bézier curve at a given &lt;paramref name = &quot;t&quot;/&gt; ∈ [0, 1].
        /// &lt;/summary&gt;
        public Point Lerp(nfloat t)
        {
        }

        /// &lt;summary&gt;
        /// Approximates the Y output value for a given input X ∈ [0,1] using a 16-step lookup table.
        /// &lt;/summary&gt;
        public nfloat Evaluate(nfloat x)
        {
        }

        /// &lt;summary&gt;
        /// Approximates the Y output value for a given input X ∈ [0,1] using binary search to the given precision.
        /// &lt;/summary&gt;
        public nfloat Evaluate(nfloat x, nfloat precision)
        {
        }

        /// &lt;summary&gt;
        /// Indexer alias for &lt;see cref = &quot;Evaluate(nfloat)&quot;/&gt;.
        /// &lt;/summary&gt;
        public nfloat this[nfloat x]
        {
            get
            {
            }
        }

        private nfloat EvaluateInternal(nfloat xTarget, int? steps = null, nfloat? precision = null)
        {
        }

        /// &lt;summary&gt;
        /// Finds the parameter &lt;c&gt;t&lt;/c&gt; ∈ [0, 1] where the curve is closest to the given &lt;paramref name = &quot;target&quot;/&gt; point.
        /// Uses 16-step approximation.
        /// &lt;/summary&gt;
        public nfloat ClosestT(Point target)
        {
        }

        /// &lt;summary&gt;
        /// Returns a new cubic Bézier easing curve with a deformation applied near the closest point to &lt;paramref name = &quot;origin&quot;/&gt;, 
        /// shifted by &lt;paramref name = &quot;delta&quot;/&gt;.
        /// &lt;/summary&gt;
        public CubicBezier Drag(Point origin, Vector delta)
        {
        }

        /// &lt;summary&gt;
        /// Returns a new cubic Bézier easing curve with a deformation applied at the given parameter &lt;paramref name = &quot;t&quot;/&gt; by &lt;paramref name = &quot;delta&quot;/&gt;.
        /// &lt;/summary&gt;
        public CubicBezier DragAt(nfloat t, Vector delta)
        {
        }

        /// &lt;summary&gt;
        /// Converts a full &lt;see cref = &quot;Curves2D.CubicBezier&quot;/&gt; into a CSS-style easing curve.
        /// The curve must begin at (0,0) and end at (1,1).
        /// &lt;/summary&gt;
        public static implicit operator CubicBezier(Curves2D.CubicBezier bezier)
        {
        }

        /// &lt;summary&gt;Equivalent to CSS `ease`: cubic-bezier(0.25, 0.1, 0.25, 1.0)&lt;/summary&gt;
        public static CubicBezier Ease
        {
            get
            {
            }
        }

        /// &lt;summary&gt;Equivalent to CSS `ease-in`: cubic-bezier(0.42, 0, 1.0, 1.0)&lt;/summary&gt;
        public static CubicBezier EaseIn
        {
            get
            {
            }
        }

        /// &lt;summary&gt;Equivalent to CSS `ease-out`: cubic-bezier(0, 0, 0.58, 1.0)&lt;/summary&gt;
        public static CubicBezier EaseOut
        {
            get
            {
            }
        }

        /// &lt;summary&gt;Equivalent to CSS `ease-in-out`: cubic-bezier(0.42, 0, 0.58, 1.0)&lt;/summary&gt;
        public static CubicBezier EaseInOut
        {
            get
            {
            }
        }
    }
}
</code></pre>
<h3 id="animationeasingpolynomialeasingcs">Animation/Easing.PolynomialEasing.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Animation;
public static partial class Easing
{
    /// &lt;summary&gt;
    /// Represents a 3rd- or 4th-degree polynomial easing function for animation timing curves.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This type can be used to approximate Bézier-based easing curves (like &lt;see cref = &quot;Easing.CubicBezier&quot;/&gt;)
    /// using polynomial coefficients, which are faster to evaluate and easier to store or serialize.
    /// &lt;/remarks&gt;
    public readonly struct PolynomialEasing
    {
        /// &lt;summary&gt;The coefficient for x⁴ (A = 0 for cubic curves).&lt;/summary&gt;
        public readonly nfloat A;
        /// &lt;summary&gt;The coefficient for x³.&lt;/summary&gt;
        public readonly nfloat B;
        /// &lt;summary&gt;The coefficient for x².&lt;/summary&gt;
        public readonly nfloat C;
        /// &lt;summary&gt;The coefficient for x¹.&lt;/summary&gt;
        public readonly nfloat D;
        /// &lt;summary&gt;The constant term.&lt;/summary&gt;
        public readonly nfloat E;
        /// &lt;summary&gt;
        /// Constructs a 3rd-degree polynomial: y = B·x³ + C·x² + D·x + E
        /// &lt;/summary&gt;
        public PolynomialEasing(nfloat b, nfloat c, nfloat d, nfloat e)
        {
        }

        /// &lt;summary&gt;
        /// Constructs a 4th-degree polynomial: y = A·x⁴ + B·x³ + C·x² + D·x + E
        /// &lt;/summary&gt;
        public PolynomialEasing(nfloat a, nfloat b, nfloat c, nfloat d, nfloat e)
        {
        }

        /// &lt;summary&gt;
        /// Approximates a &lt;see cref = &quot;Easing.CubicBezier&quot;/&gt; easing curve using a cubic polynomial.
        /// The result fits y = B·x³ + C·x² + D·x + E over the domain x ∈ [0, 1].
        /// &lt;/summary&gt;
        /// &lt;param name = &quot;bezier&quot;&gt;The Bézier curve to approximate.&lt;/param&gt;
        /// &lt;param name = &quot;samples&quot;&gt;Number of sample points to use in least-squares fitting. Default is 16.&lt;/param&gt;
        public PolynomialEasing(CubicBezier bezier, int samples = 16)
        {
        }

        /// &lt;summary&gt;
        /// Evaluates the polynomial at a given value of x ∈ [0, 1].
        /// &lt;/summary&gt;
        /// &lt;param name = &quot;x&quot;&gt;The input value (typically time).&lt;/param&gt;
        /// &lt;returns&gt;The eased value at x.&lt;/returns&gt;
        public nfloat this[nfloat x]
        {
            [DebuggerStepThrough]
            get
            {
            }
        }

        /// &lt;summary&gt;
        /// Solves a 4x4 linear system using Gaussian elimination.
        /// &lt;/summary&gt;
        /// &lt;param name = &quot;m&quot;&gt;The coefficient matrix (flattened row-major).&lt;/param&gt;
        /// &lt;param name = &quot;b&quot;&gt;The right-hand side vector.&lt;/param&gt;
        /// &lt;param name = &quot;result&quot;&gt;The resulting vector of solved coefficients.&lt;/param&gt;
        private static void SolveGaussian(Span&lt;nfloat&gt; m, Span&lt;nfloat&gt; b, Span&lt;nfloat&gt; result)
        {
        }
    }
}
</code></pre>
<h3 id="animationexponentialdecaycurvecs">Animation/ExponentialDecayCurve.cs</h3>
<pre><code class="lang-csharp">using System;
using System.Diagnostics;

namespace Xui.Core.Animation;
/// &lt;summary&gt;
/// Represents a motion curve where velocity decays exponentially over time.
/// Commonly used to simulate fling or momentum-based motion with smooth slowdown.
/// &lt;/summary&gt;
public readonly struct ExponentialDecayCurve
{
    /// &lt;summary&gt;
    /// The time at which the motion begins.
    /// &lt;/summary&gt;
    public readonly TimeSpan StartTime;
    /// &lt;summary&gt;
    /// The time at which the motion ends, determined by when velocity falls below a defined threshold.
    /// &lt;/summary&gt;
    public readonly TimeSpan EndTime;
    /// &lt;summary&gt;
    /// The decay factor per second. Lower values result in faster deceleration.
    /// &lt;/summary&gt;
    public readonly nfloat DecayPerSecond;
    /// &lt;summary&gt;
    /// The initial velocity at the start of the curve.
    /// &lt;/summary&gt;
    public readonly nfloat InitialVelocity;
    /// &lt;summary&gt;
    /// The starting position of the motion.
    /// &lt;/summary&gt;
    public readonly nfloat StartPosition;
    /// &lt;summary&gt;
    /// A typical decay factor (~0.998 per millisecond). Use for normal fling decay.
    /// &lt;/summary&gt;
    public static readonly nfloat Normal = (nfloat)0.135;
    /// &lt;summary&gt;
    /// A faster decay factor (~0.99 per millisecond). Use for snappier motion.
    /// &lt;/summary&gt;
    public static readonly nfloat Fast = (nfloat)0.00004317;
    /// &lt;summary&gt;
    /// Initializes an exponential decay motion curve.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startTime&quot;&gt;The time when motion begins.&lt;/param&gt;
    /// &lt;param name = &quot;startPosition&quot;&gt;The initial position.&lt;/param&gt;
    /// &lt;param name = &quot;initialVelocity&quot;&gt;The initial velocity (can be negative).&lt;/param&gt;
    /// &lt;param name = &quot;decayPerSecond&quot;&gt;
    /// The decay multiplier per second. A value less than 1, closer to 0 = faster decay.
    /// Recommended value is &lt;see cref = &quot;Normal&quot;/&gt;.
    /// &lt;/param&gt;
    /// &lt;param name = &quot;velocityThreshold&quot;&gt;
    /// The velocity below which motion is considered stopped (defaults to 0.5).
    /// &lt;/param&gt;
    [DebuggerStepThrough]
    public ExponentialDecayCurve(TimeSpan startTime, nfloat startPosition, nfloat initialVelocity, nfloat decayPerSecond, double velocityThreshold = 0.5)
    {
    }

    /// &lt;summary&gt;
    /// Gets the final position of the motion at &lt;see cref = &quot;EndTime&quot;/&gt;.
    /// &lt;/summary&gt;
    public nfloat FinalPosition
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the position of the motion at a given time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The time to evaluate.&lt;/param&gt;
    /// &lt;returns&gt;The interpolated position at the specified time.&lt;/returns&gt;
    public nfloat this[TimeSpan time]
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the velocity of the motion at a given time.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The time to evaluate.&lt;/param&gt;
    /// &lt;returns&gt;The current velocity at the specified time.&lt;/returns&gt;
    public nfloat VelocityAt(TimeSpan time)
    {
    }
}
</code></pre>
<h3 id="animationquadraticmotioncurvecs">Animation/QuadraticMotionCurve.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Animation;
/// &lt;summary&gt;
/// Represents a 1D motion curve under constant acceleration, defined as a quadratic function of time.
/// 
/// This curve is useful for modeling motion that decelerates smoothly to a stop,
/// such as fling or scroll-stop animations.
/// &lt;/summary&gt;
public readonly struct QuadraticMotionCurve
{
    /// &lt;summary&gt;
    /// The time at which the motion starts.
    /// &lt;/summary&gt;
    public readonly TimeSpan StartTime;
    /// &lt;summary&gt;
    /// The time at which the motion ends (i.e., when velocity reaches zero).
    /// &lt;/summary&gt;
    public readonly TimeSpan EndTime;
    /// &lt;summary&gt;
    /// The quadratic coefficient (0.5 * acceleration).
    /// &lt;/summary&gt;
    public readonly nfloat A;
    /// &lt;summary&gt;
    /// The linear coefficient (initial velocity minus adjustment).
    /// &lt;/summary&gt;
    public readonly nfloat B;
    /// &lt;summary&gt;
    /// The constant coefficient (initial position minus offset).
    /// &lt;/summary&gt;
    public readonly nfloat C;
    /// &lt;summary&gt;
    /// Initializes the curve with explicit polynomial coefficients and time range.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startTime&quot;&gt;The time when motion starts.&lt;/param&gt;
    /// &lt;param name = &quot;endTime&quot;&gt;The time when motion ends.&lt;/param&gt;
    /// &lt;param name = &quot;a&quot;&gt;The quadratic coefficient.&lt;/param&gt;
    /// &lt;param name = &quot;b&quot;&gt;The linear coefficient.&lt;/param&gt;
    /// &lt;param name = &quot;c&quot;&gt;The constant offset.&lt;/param&gt;
    [DebuggerStepThrough]
    public QuadraticMotionCurve(TimeSpan startTime, TimeSpan endTime, nfloat a, nfloat b, nfloat c)
    {
    }

    /// &lt;summary&gt;
    /// Constructs a curve from initial position, velocity, and acceleration magnitude.
    /// The acceleration is applied in the opposite direction of velocity to decelerate to zero.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startTime&quot;&gt;The time when motion starts.&lt;/param&gt;
    /// &lt;param name = &quot;startPosition&quot;&gt;Initial position.&lt;/param&gt;
    /// &lt;param name = &quot;startVelocity&quot;&gt;Initial velocity (positive or negative).&lt;/param&gt;
    /// &lt;param name = &quot;accelerationMagnitude&quot;&gt;Positive scalar magnitude of deceleration.&lt;/param&gt;
    public QuadraticMotionCurve(TimeSpan startTime, nfloat startPosition, nfloat startVelocity, nfloat accelerationMagnitude)
    {
    }

    /// &lt;summary&gt;
    /// Gets the final position of the motion at &lt;see cref = &quot;EndTime&quot;/&gt;.
    /// &lt;/summary&gt;
    public nfloat FinalPosition
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the position of the motion at the specified &lt;paramref name = &quot;time&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The time at which to evaluate the position.&lt;/param&gt;
    public nfloat this[TimeSpan time]
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Evaluates the instantaneous velocity at the specified &lt;paramref name = &quot;time&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;time&quot;&gt;The time at which to evaluate the velocity.&lt;/param&gt;
    /// &lt;returns&gt;The velocity in units per second.&lt;/returns&gt;
    public nfloat VelocityAt(TimeSpan time)
    {
    }
}
</code></pre>
<h3 id="canvascolorcs">Canvas/Color.cs</h3>
<pre><code class="lang-csharp">using System.Runtime.InteropServices;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Represents a color using red, green, blue, and alpha components, all normalized to the range [0, 1].
/// &lt;/summary&gt;
public struct Color
{
    /// &lt;summary&gt;
    /// Red component of the color, in the range [0, 1].
    /// &lt;/summary&gt;
    public nfloat Red;
    /// &lt;summary&gt;
    /// Green component of the color, in the range [0, 1].
    /// &lt;/summary&gt;
    public nfloat Green;
    /// &lt;summary&gt;
    /// Blue component of the color, in the range [0, 1].
    /// &lt;/summary&gt;
    public nfloat Blue;
    /// &lt;summary&gt;
    /// Alpha (opacity) component of the color, in the range [0, 1].
    /// &lt;/summary&gt;
    public nfloat Alpha;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;Color&quot;/&gt; with the specified red, green, blue, and alpha components.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;red&quot;&gt;Red component, normalized [0, 1]&lt;/param&gt;
    /// &lt;param name = &quot;green&quot;&gt;Green component, normalized [0, 1]&lt;/param&gt;
    /// &lt;param name = &quot;blue&quot;&gt;Blue component, normalized [0, 1]&lt;/param&gt;
    /// &lt;param name = &quot;alpha&quot;&gt;Alpha component, normalized [0, 1]&lt;/param&gt;
    public Color(nfloat red, nfloat green, nfloat blue, nfloat alpha)
    {
    }

    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;Color&quot;/&gt; from a packed 32-bit RGBA value.
    /// The value format is 0xRRGGBBAA, where each component is 8 bits.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rgba&quot;&gt;Packed RGBA value in 0xRRGGBBAA format.&lt;/param&gt;
    public Color(uint rgba)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a 32-bit RGBA value (0xRRGGBBAA) to a &lt;see cref = &quot;Color&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rgbaHex&quot;&gt;Packed RGBA hex value.&lt;/param&gt;
    public static implicit operator Color(uint rgbaHex)
    {
    }
}
</code></pre>
<h3 id="canvascolorscs">Canvas/Colors.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Provides web standard named color constants in 32-bit RGBA format (0xRRGGBBAA).
/// These match the named colors from the CSS color specification:
/// https://developer.mozilla.org/en-US/docs/Web/CSS/named-color
/// &lt;/summary&gt;
public static class Colors
{
#pragma warning disable CS1591
    public const uint Transparent = 0x00000000;
    public const uint Black = 0x000000FF;
    public const uint White = 0xFFFFFFFF;
    public const uint Red = 0xFF0000FF;
    public const uint Lime = 0x00FF00FF;
    public const uint Blue = 0x0000FFFF;
    public const uint Yellow = 0xFFFF00FF;
    public const uint Fuchsia = 0xFF00FFFF;
    public const uint Aqua = 0x00FFFFFF;
    public const uint Silver = 0xC0C0C0FF;
    public const uint Gray = 0x808080FF;
    public const uint Maroon = 0x800000FF;
    public const uint Purple = 0x800080FF;
    public const uint Green = 0x008000FF;
    public const uint Olive = 0x808000FF;
    public const uint Navy = 0x000080FF;
    public const uint Teal = 0x008080FF;
    public const uint AliceBlue = 0xf0f8ffFF;
    public const uint AntiqueWhite = 0xfaebd7FF;
    public const uint Aquamarine = 0x7fffd4FF;
    public const uint Azure = 0xf0ffffFF;
    public const uint Beige = 0xf5f5dcFF;
    public const uint Bisque = 0xffe4c4FF;
    public const uint BlanchedAlmond = 0xffebcdFF;
    public const uint BlueViolet = 0x8a2be2FF;
    public const uint Brown = 0xa52a2aFF;
    public const uint BurlyWood = 0xdeb887FF;
    public const uint CadetBlue = 0x5f9ea0FF;
    public const uint ChartReuse = 0x7fff00FF;
    public const uint Chocolate = 0xd2691eFF;
    public const uint Coral = 0xff7f50FF;
    public const uint CornflowerBlue = 0x6495edFF;
    public const uint CornSilk = 0xfff8dcFF;
    public const uint Crimson = 0xdc143cFF;
    public const uint Cyan = 0x00ffffFF;
    public const uint DarkBlue = 0x00008bFF;
    public const uint DarkCyan = 0x008b8bFF;
    public const uint DarkGoldenRod = 0xb8860bFF;
    public const uint DarkGray = 0xa9a9a9FF;
    public const uint DarkGreen = 0x006400FF;
    public const uint DarkGrey = 0xa9a9a9FF;
    public const uint DarkKhaki = 0xbdb76bFF;
    public const uint DarkMagenta = 0x8b008bFF;
    public const uint DarkOliveGreen = 0x556b2fFF;
    public const uint DarkOrange = 0xff8c00FF;
    public const uint DarkOrchid = 0x9932ccFF;
    public const uint DarkRed = 0x8b0000FF;
    public const uint DarkSalmon = 0xe9967aFF;
    public const uint DarkSeaGreen = 0x8fbc8fFF;
    public const uint DarkSlateBlue = 0x483d8bFF;
    public const uint DarkSlateGray = 0x2f4f4fFF;
    public const uint DarkSlateGrey = 0x2f4f4fFF;
    public const uint DarkTurquoise = 0x00ced1FF;
    public const uint DarkViolet = 0x9400d3FF;
    public const uint DeepPink = 0xff1493FF;
    public const uint DeepSkyBlue = 0x00bfffFF;
    public const uint DimGray = 0x696969FF;
    public const uint DimGrey = 0x696969FF;
    public const uint DodgerBlue = 0x1e90ffFF;
    public const uint FireBrick = 0xb22222FF;
    public const uint FloralWhite = 0xfffaf0FF;
    public const uint ForestGreen = 0x228b22FF;
    public const uint Gainsboro = 0xdcdcdcFF;
    public const uint GhostWhite = 0xf8f8ffFF;
    public const uint Gold = 0xffd700FF;
    public const uint GoldenRod = 0xdaa520FF;
    public const uint GreenYellow = 0xadff2fFF;
    public const uint Grey = 0x808080FF;
    public const uint Honeydew = 0xf0fff0FF;
    public const uint HotPink = 0xff69b4FF;
    public const uint IndianRed = 0xcd5c5cFF;
    public const uint Indigo = 0x4b0082FF;
    public const uint Ivory = 0xfffff0FF;
    public const uint Khaki = 0xf0e68cFF;
    public const uint Lavender = 0xe6e6faFF;
    public const uint LavenderBlush = 0xfff0f5FF;
    public const uint LawnGreen = 0x7cfc00FF;
    public const uint LemonChiffon = 0xfffacdFF;
    public const uint LightBlue = 0xadd8e6FF;
    public const uint LightCoral = 0xf08080FF;
    public const uint LightCyan = 0xe0ffffFF;
    public const uint LightGoldenRodYellow = 0xfafad2FF;
    public const uint LightGray = 0xd3d3d3FF;
    public const uint LightGreen = 0x90ee90FF;
    public const uint LightGrey = 0xd3d3d3FF;
    public const uint LightPink = 0xffb6c1FF;
    public const uint LightSalmon = 0xffa07aFF;
    public const uint LightSeaGreen = 0x20b2aaFF;
    public const uint LightSkyBlue = 0x87cefaFF;
    public const uint LightSlateGray = 0x778899FF;
    public const uint LightSlateGrey = 0x778899FF;
    public const uint LightSteelBlue = 0xb0c4deFF;
    public const uint LightYellow = 0xffffe0FF;
    public const uint LimeGreen = 0x32cd32FF;
    public const uint Linen = 0xfaf0e6FF;
    public const uint Magenta = 0xff00ffFF;
    public const uint MediumAquamarine = 0x66cdaaFF;
    public const uint MediumBlue = 0x0000cdFF;
    public const uint MediumOrchid = 0xba55d3FF;
    public const uint MediumPurple = 0x9370dbFF;
    public const uint MediumSeaGreen = 0x3cb371FF;
    public const uint MediumSlateBlue = 0x7b68eeFF;
    public const uint MediumSpringGreen = 0x00fa9aFF;
    public const uint MediumTurquoise = 0x48d1ccFF;
    public const uint MediumVioletRed = 0xc71585FF;
    public const uint MidnightBlue = 0x191970FF;
    public const uint MintCream = 0xf5fffaFF;
    public const uint MistyRose = 0xffe4e1FF;
    public const uint Moccasin = 0xffe4b5FF;
    public const uint NavajoWhite = 0xffdeadFF;
    public const uint OldLace = 0xfdf5e6FF;
    public const uint OliveDrab = 0x6b8e23FF;
    public const uint Orange = 0xffa500FF;
    public const uint OrangeRed = 0xff4500FF;
    public const uint Orchid = 0xda70d6FF;
    public const uint PaleGoldenRod = 0xeee8aaFF;
    public const uint PaleGreen = 0x98fb98FF;
    public const uint PaleTurquoise = 0xafeeeeFF;
    public const uint PaleVioletRed = 0xdb7093FF;
    public const uint PapayaWhip = 0xffefd5FF;
    public const uint PeachPuff = 0xffdab9FF;
    public const uint Peru = 0xcd853fFF;
    public const uint Pink = 0xffc0cbFF;
    public const uint Plum = 0xdda0ddFF;
    public const uint PowderBlue = 0xb0e0e6FF;
    public const uint RebeccaPurple = 0x663399FF;
    public const uint RosyBrown = 0xbc8f8fFF;
    public const uint RoyalBlue = 0x4169e1FF;
    public const uint SaddleBrown = 0x8b4513FF;
    public const uint Salmon = 0xfa8072FF;
    public const uint SandyBrown = 0xf4a460FF;
    public const uint SeaGreen = 0x2e8b57FF;
    public const uint Seashell = 0xfff5eeFF;
    public const uint Sienna = 0xa0522dFF;
    public const uint SkyBlue = 0x87ceebFF;
    public const uint SlateBlue = 0x6a5acdFF;
    public const uint SlateGray = 0x708090FF;
    public const uint SlateGrey = 0x708090FF;
    public const uint Snow = 0xfffafaFF;
    public const uint SpringGreen = 0x00ff7fFF;
    public const uint SteelBlue = 0x4682b4FF;
    public const uint Tan = 0xd2b48cFF;
    public const uint Thistle = 0xd8bfd8FF;
    public const uint Tomato = 0xff6347FF;
    public const uint Turquoise = 0x40e0d0FF;
    public const uint Violet = 0xee82eeFF;
    public const uint Wheat = 0xf5deb3FF;
    public const uint WhiteSmoke = 0xf5f5f5FF;
    public const uint YellowGreen = 0x9acd32FF;
}
</code></pre>
<h3 id="canvascornerradiuscs">Canvas/CornerRadius.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
using System.Diagnostics;

/// &lt;summary&gt;
/// Represents the radius of each corner of a rectangle, allowing for uniform or non-uniform rounding.
/// &lt;/summary&gt;
public struct CornerRadius
{
    /// &lt;summary&gt;
    /// Radius of the top-left corner.
    /// &lt;/summary&gt;
    public nfloat TopLeft;
    /// &lt;summary&gt;
    /// Radius of the top-right corner.
    /// &lt;/summary&gt;
    public nfloat TopRight;
    /// &lt;summary&gt;
    /// Radius of the bottom-right corner.
    /// &lt;/summary&gt;
    public nfloat BottomRight;
    /// &lt;summary&gt;
    /// Radius of the bottom-left corner.
    /// &lt;/summary&gt;
    public nfloat BottomLeft;
    /// &lt;summary&gt;
    /// Returns true if all corners have the same radius value.
    /// &lt;/summary&gt;
    public bool IsUniform
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Initializes a &lt;see cref = &quot;CornerRadius&quot;/&gt; with the same radius applied to all four corners.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radius&quot;&gt;The uniform radius for all corners.&lt;/param&gt;
    [DebuggerStepThrough]
    public CornerRadius(nfloat radius) : this()
    {
    }

    /// &lt;summary&gt;
    /// Initializes a &lt;see cref = &quot;CornerRadius&quot;/&gt; with individual values for each corner.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;topLeft&quot;&gt;Radius of the top-left corner.&lt;/param&gt;
    /// &lt;param name = &quot;topRight&quot;&gt;Radius of the top-right corner.&lt;/param&gt;
    /// &lt;param name = &quot;bottomRight&quot;&gt;Radius of the bottom-right corner.&lt;/param&gt;
    /// &lt;param name = &quot;bottomLeft&quot;&gt;Radius of the bottom-left corner.&lt;/param&gt;
    [DebuggerStepThrough]
    public CornerRadius(nfloat topLeft, nfloat topRight, nfloat bottomRight, nfloat bottomLeft)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a single radius value to a uniform &lt;see cref = &quot;CornerRadius&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radius&quot;&gt;The uniform corner radius.&lt;/param&gt;
    public static implicit operator CornerRadius(nfloat radius)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a single integer radius value to a uniform &lt;see cref = &quot;CornerRadius&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radius&quot;&gt;The uniform corner radius.&lt;/param&gt;
    public static implicit operator CornerRadius(int radius)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a 4-tuple of radius values to a &lt;see cref = &quot;CornerRadius&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radii&quot;&gt;Tuple representing (TopLeft, TopRight, BottomRight, BottomLeft).&lt;/param&gt;
    public static implicit operator CornerRadius(Tuple&lt;nfloat, nfloat, nfloat, nfloat&gt; radii)
    {
    }
}
</code></pre>
<h3 id="canvasfillmodecs">Canvas/FillMode.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the algorithm used to determine the &quot;insideness&quot; of a point in a path,
/// controlling how filled shapes are rendered.
/// &lt;/summary&gt;
public enum FillRule
{
    /// &lt;summary&gt;
    /// Uses the non-zero winding rule. A point is inside the path if the sum of
    /// path segment windings around it is non-zero. This is the default rule.
    /// &lt;/summary&gt;
    NonZero,
    /// &lt;summary&gt;
    /// Uses the even-odd rule. A point is inside the path if a ray drawn from it
    /// to infinity crosses the path segments an odd number of times.
    /// &lt;/summary&gt;
    EvenOdd
}
</code></pre>
<h3 id="canvasfontcs">Canvas/Font.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Describes a font used for text layout and rendering, similar to the CSS font model.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This type mirrors a simplified subset of CSS font properties as documented at:
/// https://developer.mozilla.org/en-US/docs/Web/CSS/font
///
/// &lt;para&gt;&lt;b&gt;Key differences:&lt;/b&gt;&lt;/para&gt;
/// &lt;list type=&quot;bullet&quot;&gt;
/// &lt;item&gt;&lt;description&gt;&lt;see cref = &quot;FontFamily&quot;/&gt; refers to a single font name only. No fallback list or character substitution is provided.&lt;/description&gt;&lt;/item&gt;
/// &lt;item&gt;&lt;description&gt;&lt;see cref = &quot;FontSize&quot;/&gt; and &lt;see cref = &quot;LineHeight&quot;/&gt; are specified in user-space units (e.g., pixels or points).&lt;/description&gt;&lt;/item&gt;
/// &lt;item&gt;&lt;description&gt;Font weight is numeric and roughly corresponds to CSS values between 100–900.&lt;/description&gt;&lt;/item&gt;
/// &lt;/list&gt;
/// &lt;/remarks&gt;
public ref struct Font
{
    /// &lt;summary&gt;
    /// The primary font family name. No fallback fonts are supported.
    /// &lt;/summary&gt;
    public ReadOnlySpan&lt;string&gt; FontFamily;
    /// &lt;summary&gt;
    /// The font size in user-space units.
    /// &lt;/summary&gt;
    public nfloat FontSize;
    /// &lt;summary&gt;
    /// The font style (normal, italic, oblique).
    /// &lt;/summary&gt;
    public FontStyle FontStyle;
    /// &lt;summary&gt;
    /// The numeric weight of the font. Matches common web font weights:
    /// &lt;code&gt;
    /// 100 - Thin
    /// 200 - Extra Light
    /// 300 - Light
    /// 400 - Normal
    /// 500 - Medium
    /// 600 - Semi Bold
    /// 700 - Bold
    /// 800 - Extra Bold
    /// 900 - Black
    /// &lt;/code&gt;
    /// &lt;/summary&gt;
    public nfloat FontWeight;
    /// &lt;summary&gt;
    /// The line height in user-space units. Controls vertical spacing between lines.
    /// &lt;/summary&gt;
    public nfloat LineHeight;
}
</code></pre>
<h3 id="canvasfontstylecs">Canvas/FontStyle.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
using System.Diagnostics;

/// &lt;summary&gt;
/// Represents a web-like font style, supporting &lt;c&gt;normal&lt;/c&gt;, &lt;c&gt;italic&lt;/c&gt;, and &lt;c&gt;oblique&lt;/c&gt; variations.
/// Global CSS styles like &lt;c&gt;inherit&lt;/c&gt;, &lt;c&gt;unset&lt;/c&gt;, and &lt;c&gt;initial&lt;/c&gt; are not supported.
///
/// Reference: https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
/// &lt;/summary&gt;
public struct FontStyle
{
    private readonly bool italic;
    private readonly bool oblique;
    private readonly nfloat obliqueAngle;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;FontStyle&quot;/&gt; with explicit flags for italic or oblique styling.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;italic&quot;&gt;Whether the font is italic.&lt;/param&gt;
    /// &lt;param name = &quot;oblique&quot;&gt;Whether the font is oblique (slanted).&lt;/param&gt;
    /// &lt;param name = &quot;obliqueAngle&quot;&gt;Angle for oblique style, in degrees.&lt;/param&gt;
    [DebuggerStepThrough]
    public FontStyle(bool italic, bool oblique, nfloat obliqueAngle)
    {
    }

    /// &lt;summary&gt;
    /// Gets a value indicating whether the font style is italic.
    /// &lt;/summary&gt;
    public bool IsItalic
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets a value indicating whether the font style is oblique (slanted).
    /// &lt;/summary&gt;
    public bool IsOblique
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the oblique slant angle, in degrees. Only meaningful if &lt;see cref = &quot;IsOblique&quot;/&gt; is true.
    /// Range is typically from -90° to 90°.
    /// &lt;/summary&gt;
    public nfloat ObliqueAngle
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Normal (upright) font style.
    /// &lt;/summary&gt;
    public static FontStyle Normal
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Italic font style.
    /// &lt;/summary&gt;
    public static FontStyle Italic
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Oblique font style using the default slant angle (14°).
    /// &lt;/summary&gt;
    public static FontStyle Oblique
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Creates a custom oblique font style with a specific slant angle.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;obliqueAngle&quot;&gt;The angle of the slant, in degrees. Should be between -90 and 90.&lt;/param&gt;
    /// &lt;returns&gt;A &lt;see cref = &quot;FontStyle&quot;/&gt; representing the custom oblique angle.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static FontStyle CustomOblique(nfloat obliqueAngle)
    {
    }
}
</code></pre>
<h3 id="canvasgradientstopcs">Canvas/GradientStop.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Represents a single color stop in a gradient, defined by an offset and a color.
/// Used for both linear and radial gradients.
/// &lt;/summary&gt;
public struct GradientStop
{
    /// &lt;summary&gt;
    /// The position of the stop within the gradient, typically in the range [0, 1].
    /// &lt;/summary&gt;
    public nfloat Offset;
    /// &lt;summary&gt;
    /// The color at the specified offset.
    /// &lt;/summary&gt;
    public Color Color;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;GradientStop&quot;/&gt; with a specified offset and color.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;offset&quot;&gt;Position of the color stop, usually from 0 to 1.&lt;/param&gt;
    /// &lt;param name = &quot;color&quot;&gt;Color at the given offset.&lt;/param&gt;
    public GradientStop(nfloat offset, Color color)
    {
    }

    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;GradientStop&quot;/&gt; with a specified offset and packed RGBA color.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;offset&quot;&gt;Position of the color stop, usually from 0 to 1.&lt;/param&gt;
    /// &lt;param name = &quot;color&quot;&gt;Color in packed 0xRRGGBBAA format.&lt;/param&gt;
    public GradientStop(nfloat offset, uint color)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple of &lt;see cref = &quot;nfloat&quot;/&gt; and &lt;see cref = &quot;Color&quot;/&gt; to a &lt;see cref = &quot;GradientStop&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;pair&quot;&gt;A tuple containing offset and color.&lt;/param&gt;
    public static implicit operator GradientStop((nfloat Offset, Color Color) pair)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple of &lt;see cref = &quot;nfloat&quot;/&gt; and &lt;c&gt;uint&lt;/c&gt; (0xRRGGBBAA) to a &lt;see cref = &quot;GradientStop&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;pair&quot;&gt;A tuple containing offset and packed RGBA color.&lt;/param&gt;
    public static implicit operator GradientStop((nfloat Offset, uint Color) pair)
    {
    }
}
</code></pre>
<h3 id="canvasicontextcs">Canvas/IContext.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Represents a 2D drawing context for the Xui Canvas, modeled after the HTML5 Canvas 2D context API.
/// This interface aggregates all sub-contexts responsible for different aspects of 2D rendering,
/// including state, drawing primitives, text, images, transformations, and resource management.
/// &lt;/summary&gt;
public interface IContext : IStateContext, // Handles save/restore state stack and global properties
 IPenContext, // Controls stroke/fill styles, line width, caps, joins, etc.
 IPathDrawingContext, // Handles path creation and stroking/filling
 IRectDrawingContext, // Shortcut methods for drawing and clearing rectangles
 ITextDrawingContext, // Text rendering, alignment, font settings
 IImageDrawingContext, // Drawing images, bitmaps, or image-like data
 ITransformContext, // Transform matrix manipulation (translate, scale, rotate, etc.)
 IDisposable // Ensures proper cleanup of native resources
{
}
</code></pre>
<h3 id="canvasiimagedrawingcontextcs">Canvas/IImageDrawingContext.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Defines methods for drawing image-like content onto the canvas,
/// such as bitmaps, video frames, or decoded image buffers.
/// 
/// Mirrors the image drawing APIs from the HTML5 Canvas 2D context.
/// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
/// &lt;/summary&gt;
public interface IImageDrawingContext
{
// Future members may include:
// void DrawImage(ImageSource image, nfloat dx, nfloat dy);
// void DrawImage(ImageSource image, nfloat dx, nfloat dy, nfloat dWidth, nfloat dHeight);
// void DrawImage(ImageSource image, nfloat sx, nfloat sy, nfloat sWidth, nfloat sHeight,
//                nfloat dx, nfloat dy, nfloat dWidth, nfloat dHeight);
}
</code></pre>
<h3 id="canvasipathdrawingcontextcs">Canvas/IPathDrawingContext.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Defines methods for constructing and rendering 2D paths,
/// following the HTML5 Canvas path API model.
///
/// Reference: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#paths
/// &lt;/summary&gt;
public interface IPathDrawingContext
{
    /// &lt;summary&gt;
    /// Begins a new path by resetting the current path list.
    /// &lt;/summary&gt;
    void BeginPath();
    /// &lt;summary&gt;
    /// Moves the current point to the specified location without drawing a line.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;to&quot;&gt;The destination point.&lt;/param&gt;
    void MoveTo(Point to);
    /// &lt;summary&gt;
    /// Connects the current point to the specified point with a straight line.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;to&quot;&gt;The endpoint of the line.&lt;/param&gt;
    void LineTo(Point to);
    /// &lt;summary&gt;
    /// Closes the current sub-path by drawing a straight line back to the start point.
    /// &lt;/summary&gt;
    void ClosePath();
    /// &lt;summary&gt;
    /// Draws a quadratic Bézier curve from the current point to the specified point,
    /// using the given control point.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;cp1&quot;&gt;Control point.&lt;/param&gt;
    /// &lt;param name = &quot;to&quot;&gt;End point.&lt;/param&gt;
    void CurveTo(Point cp1, Point to);
    /// &lt;summary&gt;
    /// Draws a cubic Bézier curve from the current point to the specified point,
    /// using two control points.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;cp1&quot;&gt;First control point.&lt;/param&gt;
    /// &lt;param name = &quot;cp2&quot;&gt;Second control point.&lt;/param&gt;
    /// &lt;param name = &quot;to&quot;&gt;End point.&lt;/param&gt;
    void CurveTo(Point cp1, Point cp2, Point to);
    /// &lt;summary&gt;
    /// Adds an arc to the path centered at the specified point.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;center&quot;&gt;Center of the arc.&lt;/param&gt;
    /// &lt;param name = &quot;radius&quot;&gt;Radius of the arc.&lt;/param&gt;
    /// &lt;param name = &quot;startAngle&quot;&gt;Start angle in radians.&lt;/param&gt;
    /// &lt;param name = &quot;endAngle&quot;&gt;End angle in radians.&lt;/param&gt;
    /// &lt;param name = &quot;winding&quot;&gt;Direction in which the arc is drawn.&lt;/param&gt;
    void Arc(Point center, nfloat radius, nfloat startAngle, nfloat endAngle, Winding winding = Winding.ClockWise);
    /// &lt;summary&gt;
    /// Adds an arc to the path, connecting two tangents defined by control points.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;cp1&quot;&gt;First control point.&lt;/param&gt;
    /// &lt;param name = &quot;cp2&quot;&gt;Second control point.&lt;/param&gt;
    /// &lt;param name = &quot;radius&quot;&gt;Arc radius.&lt;/param&gt;
    void ArcTo(Point cp1, Point cp2, nfloat radius);
    /// &lt;summary&gt;
    /// Adds an elliptical arc to the path.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;center&quot;&gt;Center of the ellipse.&lt;/param&gt;
    /// &lt;param name = &quot;radiusX&quot;&gt;Horizontal radius.&lt;/param&gt;
    /// &lt;param name = &quot;radiusY&quot;&gt;Vertical radius.&lt;/param&gt;
    /// &lt;param name = &quot;rotation&quot;&gt;Rotation of the ellipse, in radians.&lt;/param&gt;
    /// &lt;param name = &quot;startAngle&quot;&gt;Start angle in radians.&lt;/param&gt;
    /// &lt;param name = &quot;endAngle&quot;&gt;End angle in radians.&lt;/param&gt;
    /// &lt;param name = &quot;winding&quot;&gt;Direction in which the arc is drawn.&lt;/param&gt;
    void Ellipse(Point center, nfloat radiusX, nfloat radiusY, nfloat rotation, nfloat startAngle, nfloat endAngle, Winding winding = Winding.ClockWise);
    /// &lt;summary&gt;
    /// Adds a rectangle path to the current path.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle to add.&lt;/param&gt;
    void Rect(Rect rect);
    /// &lt;summary&gt;
    /// Adds a rounded rectangle path with a uniform radius.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle to round.&lt;/param&gt;
    /// &lt;param name = &quot;radius&quot;&gt;Corner radius.&lt;/param&gt;
    void RoundRect(Rect rect, nfloat radius);
    /// &lt;summary&gt;
    /// Adds a rounded rectangle path with per-corner radii.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle to round.&lt;/param&gt;
    /// &lt;param name = &quot;radius&quot;&gt;Corner radius object defining each corner.&lt;/param&gt;
    void RoundRect(Rect rect, CornerRadius radius);
    /// &lt;summary&gt;
    /// Fills the current path using the specified fill rule.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rule&quot;&gt;The fill rule to use (NonZero or EvenOdd).&lt;/param&gt;
    void Fill(FillRule rule = FillRule.NonZero);
    /// &lt;summary&gt;
    /// Strokes the current path using the current stroke style.
    /// &lt;/summary&gt;
    void Stroke();
    /// &lt;summary&gt;
    /// Sets the current clipping region to the current path.
    /// Subsequent drawing operations are clipped to this region.
    /// &lt;/summary&gt;
    void Clip();
}
</code></pre>
<h3 id="canvasipencontextcs">Canvas/IPenContext.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Defines properties and methods for controlling stroke and fill styles in a 2D drawing context,
/// including line caps, joins, width, dashes, and brush settings for fill and stroke.
/// &lt;/summary&gt;
public interface IPenContext
{
    /// &lt;summary&gt;
    /// Sets the global alpha value for all drawing operations.
    /// Range: 0.0 (fully transparent) to 1.0 (fully opaque).
    /// &lt;/summary&gt;
    nfloat GlobalAlpha { set; }

    /// &lt;summary&gt;
    /// Sets the style of line caps used for strokes.
    /// &lt;/summary&gt;
    LineCap LineCap { set; }

    /// &lt;summary&gt;
    /// Sets the style of line joins between segments.
    /// &lt;/summary&gt;
    LineJoin LineJoin { set; }

    /// &lt;summary&gt;
    /// Sets the width of stroked lines, in user space units.
    /// &lt;/summary&gt;
    nfloat LineWidth { set; }

    /// &lt;summary&gt;
    /// Sets the miter limit ratio for miter joins.
    /// If the ratio of miter length to line width exceeds this value, a bevel join is used instead.
    /// &lt;/summary&gt;
    nfloat MiterLimit { set; }

    /// &lt;summary&gt;
    /// Sets the phase offset for the start of the dash pattern.
    /// &lt;/summary&gt;
    nfloat LineDashOffset { set; }

    /// &lt;summary&gt;
    /// Sets the dash pattern used for stroking lines.
    /// Each element in the span represents a dash or gap length, alternating.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;segments&quot;&gt;A sequence of dash and gap lengths.&lt;/param&gt;
    void SetLineDash(ReadOnlySpan&lt;nfloat&gt; segments);
    /// &lt;summary&gt;
    /// Sets the stroke style to a solid color.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;color&quot;&gt;The stroke color.&lt;/param&gt;
    void SetStroke(Color color);
    /// &lt;summary&gt;
    /// Sets the stroke style to a linear gradient.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;linearGradient&quot;&gt;The gradient to use for stroking paths.&lt;/param&gt;
    void SetStroke(LinearGradient linearGradient);
    /// &lt;summary&gt;
    /// Sets the stroke style to a radial gradient.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radialGradient&quot;&gt;The gradient to use for stroking paths.&lt;/param&gt;
    void SetStroke(RadialGradient radialGradient);
    /// &lt;summary&gt;
    /// Sets the fill style to a solid color.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;color&quot;&gt;The fill color.&lt;/param&gt;
    void SetFill(Color color);
    /// &lt;summary&gt;
    /// Sets the fill style to a linear gradient.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;linearGradient&quot;&gt;The gradient to use for filling shapes.&lt;/param&gt;
    void SetFill(LinearGradient linearGradient);
    /// &lt;summary&gt;
    /// Sets the fill style to a radial gradient.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;radialGradient&quot;&gt;The gradient to use for filling shapes.&lt;/param&gt;
    void SetFill(RadialGradient radialGradient);
}
</code></pre>
<h3 id="canvasirectdrawingcontextcs">Canvas/IRectDrawingContext.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Provides convenience methods for drawing filled and stroked rectangles,
/// similar to the &lt;c&gt;fillRect()&lt;/c&gt; and &lt;c&gt;strokeRect()&lt;/c&gt; functions in the HTML5 Canvas API.
/// &lt;/summary&gt;
public interface IRectDrawingContext
{
    /// &lt;summary&gt;
    /// Draws the outline of the specified rectangle using the current stroke style.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle to stroke.&lt;/param&gt;
    void StrokeRect(Rect rect);
    /// &lt;summary&gt;
    /// Fills the specified rectangle using the current fill style.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle to fill.&lt;/param&gt;
    void FillRect(Rect rect);
}
</code></pre>
<h3 id="canvasistatecontextcs">Canvas/IStateContext.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Provides methods to save and restore the current drawing state,
/// including styles, transforms, and clipping paths.
/// Mirrors the behavior of the HTML5 Canvas &lt;c&gt;save()&lt;/c&gt; and &lt;c&gt;restore()&lt;/c&gt; methods.
/// &lt;/summary&gt;
public interface IStateContext
{
    /// &lt;summary&gt;
    /// Pushes the current drawing state onto the state stack.
    /// This includes styles, transformations, clipping paths, etc.
    /// &lt;/summary&gt;
    void Save();
    /// &lt;summary&gt;
    /// Pops the top state off the state stack and restores it.
    /// Any modifications made since the last &lt;see cref = &quot;Save&quot;/&gt; are discarded.
    /// &lt;/summary&gt;
    void Restore();
}
</code></pre>
<h3 id="canvasitextdrawingcontextcs">Canvas/ITextDrawingContext.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Defines methods for drawing text onto the canvas, including alignment and baseline options.
/// Mirrors the HTML5 Canvas 2D text API for &lt;c&gt;fillText()&lt;/c&gt;.
/// Also provides access to text measurement via &lt;see cref = &quot;ITextMeasureContext&quot;/&gt;.
/// &lt;/summary&gt;
public interface ITextDrawingContext : ITextMeasureContext
{
    /// &lt;summary&gt;
    /// Sets the horizontal alignment of the text relative to the given position.
    /// &lt;/summary&gt;
    TextAlign TextAlign { set; }

    /// &lt;summary&gt;
    /// Sets the vertical alignment of the text relative to the given baseline.
    /// &lt;/summary&gt;
    TextBaseline TextBaseline { set; }

    /// &lt;summary&gt;
    /// Draws filled text at the specified position using the current fill style and font settings.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;text&quot;&gt;The text string to render.&lt;/param&gt;
    /// &lt;param name = &quot;pos&quot;&gt;The position at which to start rendering the text.&lt;/param&gt;
    void FillText(string text, Point pos);
}
</code></pre>
<h3 id="canvasitextmeasurecontextcs">Canvas/ITextMeasureContext.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Provides functionality for measuring text and setting font properties.
/// Mirrors the measurement behavior of the HTML5 Canvas 2D context.
/// &lt;/summary&gt;
public interface ITextMeasureContext
{
    /// &lt;summary&gt;
    /// Measures the width and height of the specified text string using the current font.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;text&quot;&gt;The text string to measure.&lt;/param&gt;
    /// &lt;returns&gt;
    /// A &lt;see cref = &quot;Vector&quot;/&gt; representing the size of the rendered text.
    /// Typically, X is width and Y is line height or baseline ascent.
    /// &lt;/returns&gt;
    Vector MeasureText(string text);
    /// &lt;summary&gt;
    /// Sets the font used for all subsequent text drawing and measurement operations.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;font&quot;&gt;The font definition to apply.&lt;/param&gt;
    void SetFont(Font font);
}
</code></pre>
<h3 id="canvasitransformcontextcs">Canvas/ITransformContext.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Provides methods for manipulating the current transformation matrix of the drawing context.
/// This includes translation, scaling, rotation, and applying affine transformations.
/// Mirrors the transformation API of the HTML5 Canvas 2D context.
/// &lt;/summary&gt;
public interface ITransformContext
{
    /// &lt;summary&gt;
    /// Applies a translation by the specified vector.
    /// This offsets all subsequent drawing operations by the given amount.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;vector&quot;&gt;The translation vector (dx, dy).&lt;/param&gt;
    void Translate(Vector vector);
    /// &lt;summary&gt;
    /// Applies a clockwise rotation to the current transform.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;angle&quot;&gt;The rotation angle in radians.&lt;/param&gt;
    void Rotate(nfloat angle);
    /// &lt;summary&gt;
    /// Applies a scaling transformation using the specified scaling factors.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;vector&quot;&gt;The scaling vector (sx, sy).&lt;/param&gt;
    void Scale(Vector vector);
    /// &lt;summary&gt;
    /// Resets the current transformation matrix to the identity matrix,
    /// then replaces it with the specified transform.
    /// Equivalent to &lt;c&gt;ctx.setTransform(...)&lt;/c&gt; in HTML5 Canvas.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;transform&quot;&gt;The new transformation matrix to apply.&lt;/param&gt;
    void SetTransform(AffineTransform transform);
    /// &lt;summary&gt;
    /// Multiplies the current transformation matrix by the specified matrix.
    /// This is equivalent to applying an additional transformation on top of the existing one.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;matrix&quot;&gt;The matrix to multiply with the current transform.&lt;/param&gt;
    void Transform(AffineTransform matrix);
}
</code></pre>
<h3 id="canvaslineargradientcs">Canvas/LinearGradient.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Represents a linear gradient brush that transitions between colors along a straight line,
/// following the same behavior as the HTML5 Canvas &lt;c&gt;createLinearGradient()&lt;/c&gt;.
/// &lt;/summary&gt;
public ref struct LinearGradient
{
    /// &lt;summary&gt;
    /// The starting point of the gradient, in user space coordinates.
    /// &lt;/summary&gt;
    public Point StartPoint;
    /// &lt;summary&gt;
    /// The ending point of the gradient, in user space coordinates.
    /// &lt;/summary&gt;
    public Point EndPoint;
    /// &lt;summary&gt;
    /// The sequence of gradient stops that define color transitions along the line.
    /// Offsets are typically in the range [0, 1].
    /// &lt;/summary&gt;
    public ReadOnlySpan&lt;GradientStop&gt; GradientStops;
    /// &lt;summary&gt;
    /// Creates a new &lt;see cref = &quot;LinearGradient&quot;/&gt; with the given start and end points and gradient stops.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;start&quot;&gt;The start point of the gradient.&lt;/param&gt;
    /// &lt;param name = &quot;end&quot;&gt;The end point of the gradient.&lt;/param&gt;
    /// &lt;param name = &quot;gradient&quot;&gt;A span of gradient stops sorted by offset.&lt;/param&gt;
    public LinearGradient(Point start, Point end, ReadOnlySpan&lt;GradientStop&gt; gradient)
    {
    }
}
</code></pre>
<h3 id="canvaslinecapcs">Canvas/LineCap.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the shape used at the ends of lines when stroking paths.
/// Mirrors the &lt;c&gt;lineCap&lt;/c&gt; property in the HTML5 Canvas API.
/// &lt;/summary&gt;
public enum LineCap
{
    /// &lt;summary&gt;
    /// The line ends exactly at the endpoint with no additional extension. This is the default.
    /// &lt;/summary&gt;
    Butt = 0,
    /// &lt;summary&gt;
    /// The line ends with a semicircular extension, centered on the endpoint.
    /// &lt;/summary&gt;
    Round = 1,
    /// &lt;summary&gt;
    /// The line ends with a square extension equal to half the line width, extending beyond the endpoint.
    /// &lt;/summary&gt;
    Square = 2
}
</code></pre>
<h3 id="canvaslinejoincs">Canvas/LineJoin.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies how two connected lines are joined when stroking a path.
/// Mirrors the &lt;c&gt;lineJoin&lt;/c&gt; property in the HTML5 Canvas API.
/// &lt;/summary&gt;
public enum LineJoin
{
    /// &lt;summary&gt;
    /// Lines are joined with a sharp corner or extended miter, depending on the miter limit.
    /// &lt;/summary&gt;
    Miter = 0,
    /// &lt;summary&gt;
    /// Lines are joined with a circular arc, creating a rounded corner.
    /// &lt;/summary&gt;
    Round = 1,
    /// &lt;summary&gt;
    /// Lines are joined with a beveled corner by connecting the outer corners of the strokes.
    /// &lt;/summary&gt;
    Bevel = 2
}
</code></pre>
<h3 id="canvaspaintstylecs">Canvas/PaintStyle.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the type of brush or fill style used for painting shapes or strokes.
/// Helps distinguish between solid colors and gradient fills.
/// &lt;/summary&gt;
public enum PaintStyle
{
    /// &lt;summary&gt;
    /// A single, uniform color.
    /// &lt;/summary&gt;
    SolidColor = 0,
    /// &lt;summary&gt;
    /// A linear gradient that transitions colors along a straight line.
    /// &lt;/summary&gt;
    LinearGradient = 1,
    /// &lt;summary&gt;
    /// A radial gradient that transitions colors outward in a circular or elliptical shape.
    /// &lt;/summary&gt;
    RadialGradient = 2
}
</code></pre>
<h3 id="canvasradialgradientcs">Canvas/RadialGradient.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Represents a radial gradient brush that transitions colors outward from one circle to another,
/// similar to &lt;c&gt;createRadialGradient()&lt;/c&gt; in the HTML5 Canvas API.
/// &lt;/summary&gt;
public ref struct RadialGradient
{
    /// &lt;summary&gt;
    /// The center point of the starting circle (inner circle).
    /// &lt;/summary&gt;
    public Point StartCenter;
    /// &lt;summary&gt;
    /// The radius of the starting circle (inner circle), usually 0 for solid centers.
    /// &lt;/summary&gt;
    public nfloat StartRadius;
    /// &lt;summary&gt;
    /// The center point of the ending circle (outer circle).
    /// &lt;/summary&gt;
    public Point EndCenter;
    /// &lt;summary&gt;
    /// The radius of the ending circle (outer circle), defining the spread of the gradient.
    /// &lt;/summary&gt;
    public nfloat EndRadius;
    /// &lt;summary&gt;
    /// A sequence of color stops defining how colors are interpolated from the inner to the outer circle.
    /// Offsets are typically in the range [0, 1].
    /// &lt;/summary&gt;
    public ReadOnlySpan&lt;GradientStop&gt; GradientStops;
    /// &lt;summary&gt;
    /// Initializes a radial gradient that transitions between two circles.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;startCenter&quot;&gt;Center of the inner circle.&lt;/param&gt;
    /// &lt;param name = &quot;startRadius&quot;&gt;Radius of the inner circle.&lt;/param&gt;
    /// &lt;param name = &quot;endCenter&quot;&gt;Center of the outer circle.&lt;/param&gt;
    /// &lt;param name = &quot;endRadius&quot;&gt;Radius of the outer circle.&lt;/param&gt;
    /// &lt;param name = &quot;gradientStops&quot;&gt;Span of color stops defining the gradient transition.&lt;/param&gt;
    public RadialGradient(Point startCenter, nfloat startRadius, Point endCenter, nfloat endRadius, ReadOnlySpan&lt;GradientStop&gt; gradientStops)
    {
    }

    /// &lt;summary&gt;
    /// Initializes a radial gradient from a single point and radius, fading outward from a solid center.
    /// This is equivalent to setting the start radius to zero and both centers to the same point.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;center&quot;&gt;Center point of the gradient.&lt;/param&gt;
    /// &lt;param name = &quot;radius&quot;&gt;Radius of the gradient spread.&lt;/param&gt;
    /// &lt;param name = &quot;gradientStops&quot;&gt;Span of color stops defining the gradient transition.&lt;/param&gt;
    public RadialGradient(Point center, nfloat radius, ReadOnlySpan&lt;GradientStop&gt; gradientStops)
    {
    }
}
</code></pre>
<h3 id="canvassvgarcflagcs">Canvas/SVG/ArcFlag.cs</h3>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Specifies the size of the arc to be drawn when interpreting an SVG arc command.
/// Used in conjunction with the sweep flag to determine the final arc segment.
///
/// This corresponds to the &quot;large-arc-flag&quot; in the SVG path specification.
/// &lt;/summary&gt;
public enum ArcFlag
{
    /// &lt;summary&gt;
    /// Draw the smaller of the two possible arc sweeps (less than or equal to 180 degrees).
    /// &lt;/summary&gt;
    Small = 0,
    /// &lt;summary&gt;
    /// Draw the larger of the two possible arc sweeps (greater than 180 degrees).
    /// &lt;/summary&gt;
    Large = 1
}
</code></pre>
<h3 id="canvassvgextensionscs">Canvas/SVG/Extensions.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas.SVG;
/// &lt;summary&gt;
/// Provides SVG-related extension methods for the &lt;see cref = &quot;IPathDrawingContext&quot;/&gt; interface.
/// &lt;/summary&gt;
public static class Extensions
{
    /// &lt;summary&gt;
    /// Creates a &lt;see cref = &quot;PathDataBuilder&quot;/&gt; for the given path drawing context.
    /// 
    /// This enables fluent parsing or construction of SVG path commands targeting the current canvas context.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;this&quot;&gt;The path drawing context (e.g., a canvas or drawing surface).&lt;/param&gt;
    /// &lt;returns&gt;A &lt;see cref = &quot;PathDataBuilder&quot;/&gt; instance for building or parsing SVG paths.&lt;/returns&gt;
    public static PathDataBuilder PathData(this IPathDrawingContext @this)
    {
    }
}
</code></pre>
<h3 id="canvassvgpathdatabuildercs">Canvas/SVG/PathDataBuilder.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Canvas.SVG;
/// &lt;summary&gt;
/// A utility for converting parsed SVG path commands into drawing operations
/// on an &lt;see cref = &quot;IPathDrawingContext&quot;/&gt; target.
/// 
/// This builder supports both absolute (e.g., &lt;c&gt;M&lt;/c&gt;, &lt;c&gt;L&lt;/c&gt;, &lt;c&gt;C&lt;/c&gt;) and relative (e.g., &lt;c&gt;m&lt;/c&gt;, &lt;c&gt;l&lt;/c&gt;, &lt;c&gt;c&lt;/c&gt;) SVG commands,
/// and tracks the current drawing point and control points for smooth curves.
/// &lt;/summary&gt;
public ref struct PathDataBuilder
{
    /// &lt;summary&gt;
    /// The target drawing context that receives path commands.
    /// &lt;/summary&gt;
    public readonly IPathDrawingContext Sink;
    /// &lt;summary&gt;
    /// The starting point of the current subpath (used for &lt;c&gt;Z&lt;/c&gt; command).
    /// &lt;/summary&gt;
    public Point? StartPoint;
    /// &lt;summary&gt;
    /// The current position of the pen after the last command.
    /// &lt;/summary&gt;
    public Point CurrentPoint;
    /// &lt;summary&gt;
    /// The reflected control point for the next cubic Bézier curve (used in &lt;c&gt;S&lt;/c&gt;, &lt;c&gt;s&lt;/c&gt;).
    /// &lt;/summary&gt;
    public Point NextCubicControlPoint;
    /// &lt;summary&gt;
    /// The reflected control point for the next quadratic Bézier curve (used in &lt;c&gt;T&lt;/c&gt;, &lt;c&gt;t&lt;/c&gt;).
    /// &lt;/summary&gt;
    public Point NextQuadraticControlPoint;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;PathDataBuilder&quot;/&gt; targeting the specified drawing context.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;sink&quot;&gt;The drawing context that will receive the path instructions.&lt;/param&gt;
    public PathDataBuilder(IPathDrawingContext sink)
    {
    }

    /// &lt;summary&gt;
    /// Begins a new path on the drawing context.
    /// &lt;/summary&gt;
    public PathDataBuilder Begin()
    {
    }

#pragma warning disable CS1591
    public PathDataBuilder M(Point point)
    {
    }

    public PathDataBuilder m(Vector vector)
    {
    }

    public PathDataBuilder L(Point point)
    {
    }

    public PathDataBuilder l(Vector vector)
    {
    }

    public PathDataBuilder H(nfloat h)
    {
    }

    public PathDataBuilder h(nfloat h)
    {
    }

    public PathDataBuilder V(nfloat v)
    {
    }

    public PathDataBuilder v(nfloat v)
    {
    }

    public PathDataBuilder C(Point cp1, Point cp2, Point to)
    {
    }

    public PathDataBuilder c(Vector cv1, Vector cv2, Vector to)
    {
    }

    public PathDataBuilder S(Point cp, Point to)
    {
    }

    public PathDataBuilder s(Vector cv, Vector to)
    {
    }

    public PathDataBuilder Q(Point cp, Point to)
    {
    }

    public PathDataBuilder q(Vector cv, Vector to)
    {
    }

    public PathDataBuilder T(Point to)
    {
    }

    public PathDataBuilder t(Vector to)
    {
    }

    public PathDataBuilder A(Vector sr, nfloat xAxisRotationDeg, ArcFlag largeArcFlag, Winding sweepDirection, Point p2)
    {
    }

    public PathDataBuilder a(Vector v2, nfloat xAxisRotationDeg, ArcFlag largeArcFlag, Winding sweepDirection, Vector sr)
    {
    }

    public PathDataBuilder Z()
    {
    }

    public PathDataBuilder z()
    {
    }
}
</code></pre>
<h3 id="canvastextaligncs">Canvas/TextAlign.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the horizontal alignment of text relative to the drawing position.
/// Mirrors the &lt;c&gt;textAlign&lt;/c&gt; property in the HTML5 Canvas 2D API.
/// &lt;/summary&gt;
public enum TextAlign
{
    /// &lt;summary&gt;
    /// Aligns text to the start of the writing direction (left for LTR, right for RTL).
    /// &lt;/summary&gt;
    Start,
    /// &lt;summary&gt;
    /// Aligns text to the end of the writing direction (right for LTR, left for RTL).
    /// &lt;/summary&gt;
    End,
    /// &lt;summary&gt;
    /// Aligns text to the left, regardless of writing direction.
    /// &lt;/summary&gt;
    Left,
    /// &lt;summary&gt;
    /// Aligns text to the right, regardless of writing direction.
    /// &lt;/summary&gt;
    Right,
    /// &lt;summary&gt;
    /// Centers the text horizontally around the drawing position.
    /// &lt;/summary&gt;
    Center
}
</code></pre>
<h3 id="canvastextbaselinecs">Canvas/TextBaseline.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the vertical alignment of text relative to the drawing position.
/// Mirrors the &lt;c&gt;textBaseline&lt;/c&gt; property in the HTML5 Canvas 2D API.
/// &lt;/summary&gt;
public enum TextBaseline
{
    /// &lt;summary&gt;
    /// The top of the em box is aligned with the drawing position.
    /// &lt;/summary&gt;
    Top,
    /// &lt;summary&gt;
    /// The hanging baseline is aligned with the drawing position (used in some scripts like Devanagari).
    /// &lt;/summary&gt;
    Hanging,
    /// &lt;summary&gt;
    /// The middle of the text (roughly half the em height) is aligned with the drawing position.
    /// &lt;/summary&gt;
    Middle,
    /// &lt;summary&gt;
    /// The alphabetic baseline (default for Latin scripts) is aligned with the drawing position.
    /// &lt;/summary&gt;
    Alphabetic,
    /// &lt;summary&gt;
    /// The ideographic baseline is aligned with the drawing position (used in scripts like Chinese or Japanese).
    /// &lt;/summary&gt;
    Ideographic,
    /// &lt;summary&gt;
    /// The bottom of the em box is aligned with the drawing position.
    /// &lt;/summary&gt;
    Bottom
}
</code></pre>
<h3 id="canvaswindingcs">Canvas/Winding.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Canvas;
/// &lt;summary&gt;
/// Specifies the direction in which arcs or elliptical curves are drawn,
/// affecting fill and stroke behavior in path-based rendering.
/// &lt;/summary&gt;
public enum Winding : int
{
    /// &lt;summary&gt;
    /// The path is drawn in a clockwise direction.
    /// This is the default in most canvas and geometry operations.
    /// &lt;/summary&gt;
    ClockWise = 1,
    /// &lt;summary&gt;
    /// The path is drawn in a counter-clockwise direction.
    /// &lt;/summary&gt;
    CounterClockWise = 0
}
</code></pre>
<h3 id="curves2dbeziercs">Curves2D/Bezier.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Static helper methods for constructing Bézier curves.
/// &lt;/summary&gt;
public static class Bezier
{
    /// &lt;summary&gt;
    /// Creates a linear Bézier curve from two points.
    /// &lt;/summary&gt;
    public static LinearBezier Linear(Point p0, Point p1)
    {
    }

    /// &lt;summary&gt;
    /// Creates a quadratic Bézier curve from three control points.
    /// &lt;/summary&gt;
    public static QuadraticBezier Quadratic(Point p0, Point p1, Point p2)
    {
    }

    /// &lt;summary&gt;
    /// Creates a cubic Bézier curve from four control points.
    /// &lt;/summary&gt;
    public static CubicBezier Cubic(Point p0, Point p1, Point p2, Point p3)
    {
    }
}
</code></pre>
<h3 id="curves2dcubicbeziercs">Curves2D/CubicBezier.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a cubic Bézier curve defined by four control points.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A cubic Bézier curve provides smooth interpolation between &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P3&quot;/&gt;,
/// influenced by the control points &lt;see cref = &quot;P1&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;. This is commonly used in vector graphics,
/// animation timing, and layout paths.
/// &lt;/remarks&gt;
public readonly struct CubicBezier : ICurve
{
    /// &lt;summary&gt;The starting point of the curve.&lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;The first control point, influencing the curve near &lt;see cref = &quot;P0&quot;/&gt;.&lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;The second control point, influencing the curve near &lt;see cref = &quot;P3&quot;/&gt;.&lt;/summary&gt;
    public readonly Point P2;
    /// &lt;summary&gt;The ending point of the curve.&lt;/summary&gt;
    public readonly Point P3;
    /// &lt;summary&gt;
    /// Initializes a new cubic Bézier curve with the specified control points.
    /// &lt;/summary&gt;
    public CubicBezier(Point p0, Point p1, Point p2, Point p3)
    {
    }

    /// &lt;summary&gt;
    /// Computes the interpolated point on the curve at parameter &lt;paramref name = &quot;t&quot;/&gt; using De Casteljau’s algorithm.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Computes the tangent vector of the curve at parameter &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length of the curve using uniform sampling with 16 segments.
    /// &lt;/summary&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length of the curve using recursive adaptive subdivision.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;precision&quot;&gt;
    /// The tolerance value used to determine when a segment is flat enough to stop subdividing.
    /// Smaller values result in more accurate results but require more computation.
    /// &lt;/param&gt;
    public nfloat Length(nfloat precision)
    {
    }

    private static nfloat Length(Point p0, Point p1, Point p2, Point p3, nfloat tolerance)
    {
    }

    /// &lt;summary&gt;
    /// Gets the interpolated point on the curve at the specified parameter.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple of four points into a &lt;see cref = &quot;CubicBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;value&quot;&gt;A tuple representing the start point, two control points, and end point.&lt;/param&gt;
    public static implicit operator CubicBezier((Point p0, Point p1, Point p2, Point p3) value)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a &lt;see cref = &quot;QuadraticBezier&quot;/&gt; to a &lt;see cref = &quot;CubicBezier&quot;/&gt;
    /// using interpolation for smooth parameterization.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This conversion evaluates the quadratic Bézier at fixed steps (1⁄3 and 2⁄3) to generate
    /// the internal control points of the cubic, resulting in a visually smooth upgrade path.
    /// &lt;/remarks&gt;
    public static implicit operator CubicBezier(QuadraticBezier quadratic)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts this cubic Catmull–Rom spline to a &lt;see cref = &quot;CubicBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Uses the canonical Catmull–Rom to Bézier mapping, interpolating between P1 and P2.
    /// &lt;/remarks&gt;
    public static implicit operator CubicBezier(CubicSpline spline)
    {
    }

    /// &lt;summary&gt;
    /// Returns a new &lt;see cref = &quot;CubicBezier&quot;/&gt; curve where the control points &lt;c&gt;P1&lt;/c&gt; and &lt;c&gt;P2&lt;/c&gt;
    /// are adjusted based on a drag gesture at a given parametric position &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;
    /// A normalized value (between 0 and 1) representing the position on the curve where the drag occurs.
    /// &lt;/param&gt;
    /// &lt;param name = &quot;delta&quot;&gt;
    /// The drag vector representing how far the user dragged the point at &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// A new &lt;see cref = &quot;CubicBezier&quot;/&gt; with &lt;c&gt;P0&lt;/c&gt; and &lt;c&gt;P3&lt;/c&gt; unchanged,
    /// and &lt;c&gt;P1&lt;/c&gt; and &lt;c&gt;P2&lt;/c&gt; adjusted proportionally to the drag direction and distance.
    /// &lt;/returns&gt;
    /// &lt;remarks&gt;
    /// The influence of the drag on &lt;c&gt;P1&lt;/c&gt; and &lt;c&gt;P2&lt;/c&gt; is weighted quadratically based on their
    /// distance from &lt;paramref name = &quot;t&quot;/&gt; along the curve:
    /// &lt;c&gt;P1&lt;/c&gt; is influenced by &lt;c&gt;(1 - t)²&lt;/c&gt; and &lt;c&gt;P2&lt;/c&gt; by &lt;c&gt;t²&lt;/c&gt;.
    /// This preserves the endpoints while allowing intuitive manipulation of the curve shape.
    /// &lt;/remarks&gt;
    public CubicBezier Drag(nfloat t, Vector delta)
    {
    }

    /// &lt;summary&gt;
    /// Returns a new cubic Bézier curve with adjusted control points so the point on the curve
    /// nearest to &lt;paramref name = &quot;origin&quot;/&gt; is moved by &lt;paramref name = &quot;delta&quot;/&gt;.
    /// &lt;/summary&gt;
    public CubicBezier DragAt(Point origin, Vector delta)
    {
    }

    /// &lt;summary&gt;
    /// Returns a new cubic Bézier curve with adjusted control points so the point on the curve
    /// nearest to &lt;paramref name = &quot;origin&quot;/&gt; is moved by &lt;paramref name = &quot;delta&quot;/&gt;.
    /// Uses recursive refinement based on the specified &lt;paramref name = &quot;precision&quot;/&gt;.
    /// &lt;/summary&gt;
    public CubicBezier DragAt(Point origin, Vector delta, nfloat precision)
    {
    }

    /// &lt;summary&gt;
    /// Returns the parameter &lt;c&gt;t&lt;/c&gt; ∈ [0, 1] at which the curve is closest to the specified &lt;paramref name = &quot;target&quot;/&gt; point.
    /// This version uses uniform sampling with 16 segments and is fast enough for interactive use.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;target&quot;&gt;The point to compare against the curve.&lt;/param&gt;
    /// &lt;returns&gt;The approximate &lt;c&gt;t&lt;/c&gt; value where the curve is closest to &lt;paramref name = &quot;target&quot;/&gt;.&lt;/returns&gt;
    public nfloat ClosestT(Point target)
    {
    }

    /// &lt;summary&gt;
    /// Returns the parameter &lt;c&gt;t&lt;/c&gt; ∈ [0, 1] at which the curve is closest to the specified &lt;paramref name = &quot;target&quot;/&gt; point,
    /// using recursive ternary subdivision until the difference in &lt;c&gt;t&lt;/c&gt; range is less than &lt;paramref name = &quot;precision&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;target&quot;&gt;The point to compare against the curve.&lt;/param&gt;
    /// &lt;param name = &quot;precision&quot;&gt;The minimum resolution for &lt;c&gt;t&lt;/c&gt; convergence. Smaller values yield more accurate results.&lt;/param&gt;
    /// &lt;returns&gt;The &lt;c&gt;t&lt;/c&gt; value where the curve is closest to &lt;paramref name = &quot;target&quot;/&gt; within the specified &lt;paramref name = &quot;precision&quot;/&gt;.&lt;/returns&gt;
    public nfloat ClosestT(Point target, nfloat precision)
    {
    }

    private static nfloat ClosestTRecursive(CubicBezier curve, Point target, nfloat t0, nfloat t1, nfloat precision)
    {
    }
}
</code></pre>
<h3 id="curves2dcubicsplinecs">Curves2D/CubicSpline.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a 4-point spline segment using Catmull–Rom interpolation.
/// The curve interpolates smoothly between &lt;see cref = &quot;P1&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Catmull–Rom splines are useful for generating smooth curves through a sequence of points
/// with minimal configuration. This implementation produces a C¹-continuous cubic curve,
/// influenced by neighboring control points &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P3&quot;/&gt;.
/// The segment can also be converted into a &lt;see cref = &quot;CubicBezier&quot;/&gt; for drawing or compatibility.
/// &lt;/remarks&gt;
public readonly struct CubicSpline : ICurve
{
    /// &lt;summary&gt;The control point before the start of the curve.&lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;The starting point of the interpolated segment.&lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;The ending point of the interpolated segment.&lt;/summary&gt;
    public readonly Point P2;
    /// &lt;summary&gt;The control point after the end of the curve.&lt;/summary&gt;
    public readonly Point P3;
    /// &lt;summary&gt;
    /// Initializes a new Catmull–Rom spline segment from four control points.
    /// &lt;/summary&gt;
    public CubicSpline(Point p0, Point p1, Point p2, Point p3)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the point on the spline at the given parameter &lt;paramref name = &quot;t&quot;/&gt; using the Catmull–Rom formula.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Computes the tangent vector at parameter &lt;paramref name = &quot;t&quot;/&gt; by differentiating the spline.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length of the curve using uniform sampling with 16 segments.
    /// &lt;/summary&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length using recursive adaptive subdivision.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;precision&quot;&gt;The tolerance used to decide subdivision depth.&lt;/param&gt;
    public nfloat Length(nfloat precision)
    {
    }

    private static nfloat Length(Point p0, Point p1, Point p2, Point p3, nfloat tolerance)
    {
    }

    /// &lt;summary&gt;
    /// Indexer-style access to evaluate the curve at a given parameter.
    /// &lt;/summary&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Converts this Catmull–Rom spline segment to an equivalent &lt;see cref = &quot;CubicBezier&quot;/&gt;.
    /// The resulting curve interpolates between &lt;see cref = &quot;P1&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator CubicBezier(CubicSpline s)
    {
    }
}
</code></pre>
<h3 id="curves2dicurvecs">Curves2D/ICurve.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a common interface for evaluable 2D curves.
/// &lt;/summary&gt;
public interface ICurve
{
    /// &lt;summary&gt;
    /// Evaluates the curve at the given normalized parameter t in [0, 1].
    /// &lt;/summary&gt;
    Point Lerp(nfloat t);
    /// &lt;summary&gt;
    /// Computes the tangent vector at the specified t.
    /// &lt;/summary&gt;
    Vector Tangent(nfloat t);
    /// &lt;summary&gt;
    /// Provides indexer access as an alias for &lt;see cref = &quot;Lerp&quot;/&gt;.
    /// &lt;/summary&gt;
    Point this[nfloat t] { get; }

    /// &lt;summary&gt;
    /// Computes an approximate arc length using 16 steps.
    /// &lt;/summary&gt;
    nfloat Length();
    /// &lt;summary&gt;
    /// Computes a refined approximation of arc length with a specified precision.
    /// &lt;/summary&gt;
    nfloat Length(nfloat precision);
}
</code></pre>
<h3 id="curves2dlinearbeziercs">Curves2D/LinearBezier.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a linear Bézier curve, equivalent to a straight line between two points.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This is the simplest form of Bézier curve, defined by two points &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P1&quot;/&gt;.
/// It is often used for edges of polygonal paths or degenerate forms of higher-order Béziers.
/// &lt;/remarks&gt;
public readonly struct LinearBezier : ICurve
{
    /// &lt;summary&gt;The start point of the curve.&lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;The end point of the curve.&lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;LinearBezier&quot;/&gt; curve with the given start and end points.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;p0&quot;&gt;The starting point.&lt;/param&gt;
    /// &lt;param name = &quot;p1&quot;&gt;The ending point.&lt;/param&gt;
    public LinearBezier(Point p0, Point p1)
    {
    }

    /// &lt;summary&gt;
    /// Computes the point on the line at parameter &lt;paramref name = &quot;t&quot;/&gt; using linear interpolation.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Returns the constant tangent vector of the line segment.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;The curve parameter (ignored since the tangent is constant).&lt;/param&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Returns the exact length of the line segment.
    /// &lt;/summary&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Returns the length of the line segment. This overload ignores the &lt;paramref name = &quot;precision&quot;/&gt; parameter.
    /// &lt;/summary&gt;
    public nfloat Length(nfloat precision)
    {
    }

    /// &lt;summary&gt;
    /// Indexer-style access to the interpolated point at parameter &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/summary&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple of two points into a &lt;see cref = &quot;LinearBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator LinearBezier((Point p0, Point p1) value)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts this &lt;see cref = &quot;LinearBezier&quot;/&gt; to a &lt;see cref = &quot;QuadraticBezier&quot;/&gt; curve.
    /// The intermediate point is set to the midpoint for visual smoothness.
    /// &lt;/summary&gt;
    public static implicit operator QuadraticBezier(LinearBezier linear)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts this &lt;see cref = &quot;LinearBezier&quot;/&gt; to a &lt;see cref = &quot;CubicBezier&quot;/&gt; curve.
    /// Intermediate control points are interpolated at 1/3 and 2/3 for smooth spacing.
    /// &lt;/summary&gt;
    public static implicit operator CubicBezier(LinearBezier linear)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a &lt;see cref = &quot;LinearSpline&quot;/&gt; to a &lt;see cref = &quot;LinearBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator LinearBezier(LinearSpline spline)
    {
    }
}
</code></pre>
<h3 id="curves2dlinearsplinecs">Curves2D/LinearSpline.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a linear spline segment between two points.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A linear spline defines a straight-line interpolation between &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P1&quot;/&gt;.
/// It is the simplest form of spline, useful for polyline paths, control handles, and degenerate Bézier cases.
/// &lt;/remarks&gt;
public readonly struct LinearSpline : ICurve
{
    /// &lt;summary&gt;
    /// The starting point of the line segment.
    /// &lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;
    /// The ending point of the line segment.
    /// &lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;LinearSpline&quot;/&gt; segment between two points.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;p0&quot;&gt;The starting point of the spline.&lt;/param&gt;
    /// &lt;param name = &quot;p1&quot;&gt;The ending point of the spline.&lt;/param&gt;
    public LinearSpline(Point p0, Point p1)
    {
    }

    /// &lt;summary&gt;
    /// Interpolates a point on the segment at the specified parameter.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    /// &lt;returns&gt;The interpolated point on the line.&lt;/returns&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Gets the constant tangent vector of the line segment.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter (unused, since the tangent is constant).&lt;/param&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the point on the spline at the specified parameter.
    /// &lt;/summary&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns the length of the segment.
    /// &lt;/summary&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Returns the length of the segment. Precision is ignored for linear splines.
    /// &lt;/summary&gt;
    public nfloat Length(nfloat precision)
    {
    }

    /// &lt;summary&gt;
    /// Converts this linear spline to a &lt;see cref = &quot;LinearBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator LinearBezier(LinearSpline s)
    {
    }
}
</code></pre>
<h3 id="curves2dquadraticbeziercs">Curves2D/QuadraticBezier.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a quadratic Bézier curve defined by three control points.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A quadratic Bézier curve smoothly interpolates between &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;.
/// The curve is influenced by a single control point &lt;see cref = &quot;P1&quot;/&gt;.
/// Quadratic Béziers are widely used in vector graphics, font rendering, and easing functions.
/// &lt;/remarks&gt;
public readonly struct QuadraticBezier : ICurve
{
    /// &lt;summary&gt;The starting point of the curve.&lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;The control point that influences the curvature of the segment.&lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;The ending point of the curve.&lt;/summary&gt;
    public readonly Point P2;
    /// &lt;summary&gt;
    /// Initializes a new quadratic Bézier curve with the specified control points.
    /// &lt;/summary&gt;
    public QuadraticBezier(Point p0, Point p1, Point p2)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the curve at parameter &lt;paramref name = &quot;t&quot;/&gt; using De Casteljau’s algorithm.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    /// &lt;returns&gt;The interpolated point on the curve.&lt;/returns&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Computes the tangent vector at parameter &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter in the range [0, 1].&lt;/param&gt;
    /// &lt;returns&gt;The tangent vector at the specified point.&lt;/returns&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length using uniform sampling over 16 segments.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The approximate total length of the curve.&lt;/returns&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length using recursive adaptive subdivision.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;precision&quot;&gt;The maximum allowed error for curve flatness.&lt;/param&gt;
    public nfloat Length(nfloat precision)
    {
    }

    private static nfloat Length(Point a, Point b, Point c, nfloat tolerance)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the point on the curve at the specified parameter.
    /// &lt;/summary&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Converts a tuple of 3 points to a &lt;see cref = &quot;QuadraticBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator QuadraticBezier((Point p0, Point p1, Point p2) value)
    {
    }

    /// &lt;summary&gt;
    /// Converts a &lt;see cref = &quot;QuadraticSpline&quot;/&gt; to a &lt;see cref = &quot;QuadraticBezier&quot;/&gt;.
    /// &lt;/summary&gt;
    public static implicit operator QuadraticBezier(QuadraticSpline spline)
    {
    }

    /// &lt;summary&gt;
    /// Adjusts the control point to drag the curve at &lt;paramref name = &quot;t&quot;/&gt; by the given delta.
    /// Keeps &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt; fixed.
    /// &lt;/summary&gt;
    public QuadraticBezier Drag(nfloat t, Vector delta)
    {
    }

    /// &lt;summary&gt;
    /// Adjusts the control point so that the curve is moved near &lt;paramref name = &quot;origin&quot;/&gt; by &lt;paramref name = &quot;delta&quot;/&gt;.
    /// Uses coarse sampling to find the closest point.
    /// &lt;/summary&gt;
    public QuadraticBezier DragAt(Point origin, Vector delta)
    {
    }

    /// &lt;summary&gt;
    /// Adjusts the control point so that the curve is moved near &lt;paramref name = &quot;origin&quot;/&gt; by &lt;paramref name = &quot;delta&quot;/&gt;.
    /// Uses adaptive precision to locate the closest point.
    /// &lt;/summary&gt;
    public QuadraticBezier DragAt(Point origin, Vector delta, nfloat precision)
    {
    }

    /// &lt;summary&gt;
    /// Finds the &lt;c&gt;t&lt;/c&gt; value where the curve is closest to &lt;paramref name = &quot;target&quot;/&gt;.
    /// Uses uniform sampling across 16 points.
    /// &lt;/summary&gt;
    public nfloat ClosestT(Point target)
    {
    }

    /// &lt;summary&gt;
    /// Finds the &lt;c&gt;t&lt;/c&gt; value where the curve is closest to &lt;paramref name = &quot;target&quot;/&gt;.
    /// Uses recursive ternary subdivision with the specified &lt;paramref name = &quot;precision&quot;/&gt;.
    /// &lt;/summary&gt;
    public nfloat ClosestT(Point target, nfloat precision)
    {
    }

    private static nfloat ClosestTRecursive(QuadraticBezier curve, Point target, nfloat t0, nfloat t1, nfloat precision)
    {
    }
}
</code></pre>
<h3 id="curves2dquadraticsplinecs">Curves2D/QuadraticSpline.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Represents a 3-point quadratic spline segment (parabolic arc) defined by a start point, control point, and end point.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// This spline uses the De Casteljau algorithm for interpolation and arc length approximation.
/// The curve passes through &lt;see cref = &quot;P0&quot;/&gt; and &lt;see cref = &quot;P2&quot;/&gt;, with &lt;see cref = &quot;P1&quot;/&gt; acting as the control point that defines curvature.
/// &lt;/remarks&gt;
public readonly struct QuadraticSpline : ICurve
{
    /// &lt;summary&gt;The start point of the spline.&lt;/summary&gt;
    public readonly Point P0;
    /// &lt;summary&gt;The control point that defines the curvature of the arc.&lt;/summary&gt;
    public readonly Point P1;
    /// &lt;summary&gt;The end point of the spline.&lt;/summary&gt;
    public readonly Point P2;
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;QuadraticSpline&quot;/&gt; with the given start, control, and end points.
    /// &lt;/summary&gt;
    public QuadraticSpline(Point p0, Point p1, Point p2)
    {
    }

    /// &lt;summary&gt;
    /// Computes the point on the spline at parameter &lt;paramref name = &quot;t&quot;/&gt; using De Casteljau interpolation.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter between 0 and 1.&lt;/param&gt;
    public Point Lerp(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Computes the tangent vector at parameter &lt;paramref name = &quot;t&quot;/&gt; on the spline.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;t&quot;&gt;A normalized parameter between 0 and 1.&lt;/param&gt;
    public Vector Tangent(nfloat t)
    {
    }

    /// &lt;summary&gt;
    /// Approximates the total arc length of the spline using a fixed 16-sample De Casteljau subdivision.
    /// &lt;/summary&gt;
    public nfloat Length()
    {
    }

    /// &lt;summary&gt;
    /// Approximates the arc length with adaptive subdivision using the specified precision tolerance.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;precision&quot;&gt;The maximum allowed error in the approximation.&lt;/param&gt;
    public nfloat Length(nfloat precision)
    {
    }

    private static nfloat Length(Point a, Point b, Point c, nfloat tolerance)
    {
    }

    /// &lt;summary&gt;
    /// Evaluates the point on the spline at parameter &lt;paramref name = &quot;t&quot;/&gt;.
    /// &lt;/summary&gt;
    public Point this[nfloat t]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Converts this spline to a &lt;see cref = &quot;QuadraticBezier&quot;/&gt; curve with the same control points.
    /// &lt;/summary&gt;
    public static implicit operator QuadraticBezier(QuadraticSpline s)
    {
    }
}
</code></pre>
<h3 id="curves2dsplinecs">Curves2D/Spline.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.Curves2D;
/// &lt;summary&gt;
/// Provides factory methods for creating spline segments of various degrees.
/// &lt;/summary&gt;
public static class Spline
{
    /// &lt;summary&gt;
    /// Creates a linear spline (degree 1) between two points.
    /// &lt;/summary&gt;
    public static LinearSpline Linear(Point p0, Point p1)
    {
    }

    /// &lt;summary&gt;
    /// Creates a quadratic spline (degree 2) between three points.
    /// &lt;/summary&gt;
    public static QuadraticSpline Quadratic(Point p0, Point p1, Point p2)
    {
    }

    /// &lt;summary&gt;
    /// Creates a cubic spline (degree 3) using Catmull–Rom interpolation through P1 and P2.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This produces a smooth segment influenced by surrounding control points &lt;paramref name = &quot;p0&quot;/&gt; and &lt;paramref name = &quot;p3&quot;/&gt;.
    /// &lt;/remarks&gt;
    public static CubicSpline Cubic(Point p0, Point p1, Point p2, Point p3)
    {
    }
}
</code></pre>
<h3 id="globalusingscs">GlobalUsings.cs</h3>
<pre><code class="lang-csharp">#pragma warning disable CS8981
global using nfloat = System.Runtime.InteropServices.NFloat;
#pragma warning restore
global using System.Diagnostics;
global using System.ComponentModel;
</code></pre>
<h3 id="math2daffinetransformcs">Math2D/AffineTransform.cs</h3>
<pre><code class="lang-csharp">using System.Diagnostics;

namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents a 2D affine transformation matrix in the form:
/// &lt;code&gt;
/// | A C Tx |
/// | B D Ty |
/// | 0 0  1 |
/// &lt;/code&gt;
/// Used for rotating, scaling, translating, and skewing 2D vectors or points.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Transformation is applied as:
/// &lt;code&gt;
/// | x' |   | A C Tx |   | x |
/// | y' | = | B D Ty | * | y |
/// | 1  |   | 0 0  1 |   | 1 |
/// &lt;/code&gt;
/// &lt;/remarks&gt;
public struct AffineTransform
{
    /// &lt;summary&gt;The matrix component in the first row, first column (scale X / rotate).&lt;/summary&gt;
    public nfloat A;
    /// &lt;summary&gt;The matrix component in the second row, first column (shear Y / rotate).&lt;/summary&gt;
    public nfloat B;
    /// &lt;summary&gt;The matrix component in the first row, second column (shear X / rotate).&lt;/summary&gt;
    public nfloat C;
    /// &lt;summary&gt;The matrix component in the second row, second column (scale Y / rotate).&lt;/summary&gt;
    public nfloat D;
    /// &lt;summary&gt;The translation component along the X axis.&lt;/summary&gt;
    public nfloat Tx;
    /// &lt;summary&gt;The translation component along the Y axis.&lt;/summary&gt;
    public nfloat Ty;
    /// &lt;summary&gt;The identity transform (no scale, rotation, or translation).&lt;/summary&gt;
    public static readonly AffineTransform Identity = new AffineTransform(1, 0, 0, 1, 0, 0);
    /// &lt;summary&gt;
    /// Returns the inverse of this affine transform.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This operation assumes the transform is invertible. Division by a zero determinant will cause a runtime exception.
    /// &lt;/remarks&gt;
    public AffineTransform Inverse
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns the determinant of the 2×2 linear portion of the matrix.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This value determines if the matrix is invertible. A value of 0 means the matrix cannot be inverted.
    /// &lt;/remarks&gt;
    public nfloat Determinant
    {
        [DebuggerStepThrough]
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Creates a rotation transform around the origin using the given angle in radians.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static AffineTransform Rotate(nfloat angle)
    {
    }

    /// &lt;summary&gt;
    /// Creates a translation transform using the specified offset vector.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static AffineTransform Translate(Vector v)
    {
    }

    /// &lt;summary&gt;
    /// Creates a scaling transform using the specified scale vector.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static AffineTransform Scale(Vector v)
    {
    }

    /// &lt;summary&gt;
    /// Creates a shear (skew) transformation along the X and Y axes.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;shearX&quot;&gt;The shear factor in the X direction.&lt;/param&gt;
    /// &lt;param name = &quot;shearY&quot;&gt;The shear factor in the Y direction.&lt;/param&gt;
    [DebuggerStepThrough]
    public static AffineTransform Shear(nfloat shearX, nfloat shearY)
    {
    }

    /// &lt;summary&gt;
    /// Constructs an affine transform with the specified matrix coefficients.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public AffineTransform(nfloat a, nfloat b, nfloat c, nfloat d, nfloat tx, nfloat ty)
    {
    }

    /// &lt;summary&gt;
    /// Applies only the linear portion (scale, rotation, shear) of this transform to a &lt;see cref = &quot;Vector&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Translation is not applied. Use this to transform directions, movement deltas, or normals.
    /// &lt;/remarks&gt;
    /// &lt;param name = &quot;t&quot;&gt;The affine transform.&lt;/param&gt;
    /// &lt;param name = &quot;v&quot;&gt;The vector to transform.&lt;/param&gt;
    /// &lt;returns&gt;A new &lt;see cref = &quot;Vector&quot;/&gt; with the linear transform applied.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static Vector operator *(AffineTransform t, Vector v)
    {
    }

    /// &lt;summary&gt;
    /// Applies this transform to a &lt;see cref = &quot;Point&quot;/&gt;, including translation.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This operation applies the full affine matrix, including scale, rotation, shear, and translation.
    /// Use this when transforming coordinates in space (e.g., an element's position).
    /// &lt;/remarks&gt;
    /// &lt;param name = &quot;t&quot;&gt;The affine transform.&lt;/param&gt;
    /// &lt;param name = &quot;p&quot;&gt;The point to transform.&lt;/param&gt;
    /// &lt;returns&gt;A new &lt;see cref = &quot;Point&quot;/&gt; with the transform applied.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static Point operator *(AffineTransform t, Point p)
    {
    }

    /// &lt;summary&gt;
    /// Composes two affine transforms using matrix multiplication.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A new transform representing the application of &lt;paramref name = &quot;rhs&quot;/&gt; followed by &lt;paramref name = &quot;lhs&quot;/&gt;.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static AffineTransform operator *(AffineTransform lhs, AffineTransform rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override string ToString()
    {
    }
}
</code></pre>
<h3 id="math2dframecs">Math2D/Frame.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents thickness values for each edge of a rectangular element.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A &lt;see cref = &quot;Frame&quot;/&gt; defines spacing from the left, top, right, and bottom edges.
/// It is typically used for layout constructs such as &lt;c&gt;Margin&lt;/c&gt;, &lt;c&gt;Padding&lt;/c&gt;, or &lt;c&gt;BorderWidth&lt;/c&gt;.
/// Unlike &lt;see cref = &quot;Rect&quot;/&gt;, it does not represent position or size—only edge offsets.
/// &lt;/remarks&gt;
public struct Frame
{
    /// &lt;summary&gt;The thickness of the top edge.&lt;/summary&gt;
    public nfloat Top;
    /// &lt;summary&gt;The thickness of the right edge.&lt;/summary&gt;
    public nfloat Right;
    /// &lt;summary&gt;The thickness of the bottom edge.&lt;/summary&gt;
    public nfloat Bottom;
    /// &lt;summary&gt;The thickness of the left edge.&lt;/summary&gt;
    public nfloat Left;
    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if all four edges have equal thickness.
    /// &lt;/summary&gt;
    public bool IsUniform
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the total horizontal edge thickness (left + right).
    /// &lt;/summary&gt;
    public nfloat TotalWidth
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the total vertical edge thickness (top + bottom).
    /// &lt;/summary&gt;
    public nfloat TotalHeight
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// A frame with all edge values set to zero.
    /// &lt;/summary&gt;
    public static readonly Frame Zero = new Frame();
    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;Frame&quot;/&gt; with all edges set to zero.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Frame()
    {
    }

    /// &lt;summary&gt;
    /// Initializes a new &lt;see cref = &quot;Frame&quot;/&gt; with the specified edge thicknesses.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;top&quot;&gt;Top edge thickness.&lt;/param&gt;
    /// &lt;param name = &quot;right&quot;&gt;Right edge thickness.&lt;/param&gt;
    /// &lt;param name = &quot;bottom&quot;&gt;Bottom edge thickness.&lt;/param&gt;
    /// &lt;param name = &quot;left&quot;&gt;Left edge thickness.&lt;/param&gt;
    [DebuggerStepThrough]
    public Frame(nfloat top, nfloat right, nfloat bottom, nfloat left)
    {
    }

    /// &lt;summary&gt;
    /// Converts a 4-tuple (top, right, bottom, left) to a &lt;see cref = &quot;Frame&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame((nfloat top, nfloat right, nfloat bottom, nfloat left) value)
    {
    }

    /// &lt;summary&gt;
    /// Converts a 2-tuple (horizontal, vertical) to a &lt;see cref = &quot;Frame&quot;/&gt;.
    /// Horizontal is applied to left and right; vertical to top and bottom.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame((nfloat horizontal, nfloat vertical) value)
    {
    }

    /// &lt;summary&gt;
    /// Converts a scalar value into a uniform &lt;see cref = &quot;Frame&quot;/&gt; for all sides.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame(nfloat value)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts an &lt;see cref = &quot;int &quot;/&gt; to a &lt;see cref = &quot;Frame&quot;/&gt;,
    /// applying the same value to all four sides (Left, Top, Right, Bottom).
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;value&quot;&gt;The integer value to apply uniformly to all sides.&lt;/param&gt;
    /// &lt;returns&gt;A &lt;see cref = &quot;Frame&quot;/&gt; with all sides set to &lt;paramref name = &quot;value&quot;/&gt;.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame(int value)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a &lt;see cref = &quot;double &quot;/&gt; to a &lt;see cref = &quot;Frame&quot;/&gt;,
    /// applying the same value to all four sides (Left, Top, Right, Bottom).
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;value&quot;&gt;The double value to apply uniformly to all sides.&lt;/param&gt;
    /// &lt;returns&gt;A &lt;see cref = &quot;Frame&quot;/&gt; with all sides set to &lt;paramref name = &quot;value&quot;/&gt;.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame(double value)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a &lt;see cref = &quot;float &quot;/&gt; to a &lt;see cref = &quot;Frame&quot;/&gt;,
    /// applying the same value to all four sides (Left, Top, Right, Bottom).
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;value&quot;&gt;The float value to apply uniformly to all sides.&lt;/param&gt;
    /// &lt;returns&gt;A &lt;see cref = &quot;Frame&quot;/&gt; with all sides set to &lt;paramref name = &quot;value&quot;/&gt;.&lt;/returns&gt;
    [DebuggerStepThrough]
    public static implicit operator Frame(float value)
    {
    }

    /// &lt;summary&gt;
    /// Scales all edges of the frame by the specified scalar.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Frame operator *(Frame lhs, nfloat rhs)
    {
    }

    /// &lt;summary&gt;
    /// Adds the corresponding edge thicknesses of two frames.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Frame operator +(Frame lhs, Frame rhs)
    {
    }

    /// &lt;summary&gt;
    /// Subtracts the corresponding edge thicknesses of two frames.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Frame operator -(Frame lhs, Frame rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns a frame containing the maximum value for each edge from two frames.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Frame Max(Frame lhs, Frame rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns a frame containing the minimum value for each edge from two frames.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Frame Min(Frame lhs, Frame rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override string ToString()
    {
    }

    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if all edge values match exactly.
    /// &lt;/summary&gt;
    public static bool operator ==(Frame left, Frame right)
    {
    }

    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if any edge value differs.
    /// &lt;/summary&gt;
    public static bool operator !=(Frame lhs, Frame rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override bool Equals(object? obj)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override int GetHashCode()
    {
    }
}
</code></pre>
<h3 id="math2dpointcs">Math2D/Point.cs</h3>
<pre><code class="lang-csharp">using System.Runtime.CompilerServices;

namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents a point in 2D space, defined by its &lt;see cref = &quot;X&quot;/&gt; and &lt;see cref = &quot;Y&quot;/&gt; coordinates.
/// &lt;/summary&gt;
public struct Point
{
    /// &lt;summary&gt;The X-coordinate of the point.&lt;/summary&gt;
    public nfloat X;
    /// &lt;summary&gt;The Y-coordinate of the point.&lt;/summary&gt;
    public nfloat Y;
    /// &lt;summary&gt;A point at the origin (0, 0).&lt;/summary&gt;
    public static readonly Point Zero = (0, 0);
    /// &lt;summary&gt;
    /// A point at (1, 1), useful for normalized coordinates or vector math.
    /// &lt;/summary&gt;
    public static readonly Point One = (1, 1);
    /// &lt;summary&gt;
    /// Initializes a new point with the specified coordinates.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Point(nfloat x, nfloat y)
    {
    }

    /// &lt;summary&gt;
    /// Linearly interpolates between two points by &lt;paramref name = &quot;step&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;start&quot;&gt;The start point.&lt;/param&gt;
    /// &lt;param name = &quot;end&quot;&gt;The end point.&lt;/param&gt;
    /// &lt;param name = &quot;step&quot;&gt;A value from 0 to 1 indicating the interpolation position.&lt;/param&gt;
    [DebuggerStepThrough]
    public static Point Lerp(Point start, Point end, nfloat step)
    {
    }

    /// &lt;summary&gt;
    /// Returns the Euclidean distance between two points.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat Distance(Point a, Point b)
    {
    }

    /// &lt;summary&gt;
    /// Returns the squared Euclidean distance between two points (no square root).
    /// Useful for performance comparisons or ordering by proximity.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat SquaredDistance(Point a, Point b)
    {
    }

    /// &lt;summary&gt;
    /// Returns the Manhattan (taxicab) distance between two points.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// The sum of the absolute horizontal and vertical distances. 
    /// Often used in grid-based or discrete movement systems.
    /// &lt;/remarks&gt;
    [DebuggerStepThrough]
    public static nfloat TaxicabDistance(Point a, Point b)
    {
    }

    /// &lt;summary&gt;
    /// Returns the vector difference from one point to another.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator -(Point lhs, Point rhs)
    {
    }

    /// &lt;summary&gt;
    /// Offsets a point by a vector.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Point operator +(Point lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Subtracts a vector from a point, offsetting it in the opposite direction.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Point operator -(Point lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Converts a tuple to a point.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Point(ValueTuple&lt;nfloat, nfloat&gt; tuple)
    {
    }

    /// &lt;summary&gt;
    /// Explicitly converts a vector to a point (drops directional semantics).
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static explicit operator Point(Vector vector)
    {
    }

    /// &lt;summary&gt;
    /// Determines whether two points have equal coordinates.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator ==(Point lhs, Point rhs)
    {
    }

    /// &lt;summary&gt;
    /// Determines whether two points differ in any coordinate.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator !=(Point lhs, Point rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override string ToString()
    {
    }

    /// &lt;inheritdoc/&gt;
    public override bool Equals(object? obj)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if this point has the same coordinates as another.
    /// &lt;/summary&gt;
    public bool Equals(Point other)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override int GetHashCode()
    {
    }
}
</code></pre>
<h3 id="math2drectcs">Math2D/Rect.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Set;

namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents a rectangle in 2D space, defined by its origin (&lt;see cref = &quot;X&quot;/&gt;, &lt;see cref = &quot;Y&quot;/&gt;)
/// and its dimensions (&lt;see cref = &quot;Width&quot;/&gt;, &lt;see cref = &quot;Height&quot;/&gt;).
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Unlike &lt;see cref = &quot;Frame&quot;/&gt;, which represents edge thicknesses around a box, 
/// &lt;see cref = &quot;Rect&quot;/&gt; defines a positioned, sized area used for layout and rendering.
/// &lt;/remarks&gt;
public struct Rect : INonEnumerableSet&lt;Point&gt;
{
    /// &lt;summary&gt;The X-coordinate of the rectangle’s top-left corner.&lt;/summary&gt;
    public nfloat X;
    /// &lt;summary&gt;The Y-coordinate of the rectangle’s top-left corner.&lt;/summary&gt;
    public nfloat Y;
    /// &lt;summary&gt;The width of the rectangle.&lt;/summary&gt;
    public nfloat Width;
    /// &lt;summary&gt;The height of the rectangle.&lt;/summary&gt;
    public nfloat Height;
    /// &lt;summary&gt;
    /// Creates a new &lt;see cref = &quot;Rect&quot;/&gt; from position and size.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect(nfloat x, nfloat y, nfloat width, nfloat height)
    {
    }

    /// &lt;summary&gt;
    /// Creates a new &lt;see cref = &quot;Rect&quot;/&gt; from a top-left point and a size.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect(Point topLeft, Size size)
    {
    }

    /// &lt;summary&gt;
    /// Creates a new &lt;see cref = &quot;Rect&quot;/&gt; from a top-left vector and a size.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect(Vector topLeft, Size size)
    {
    }

    /// &lt;summary&gt;Returns the top-left point of the rectangle.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Point TopLeft
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the top-center point of the rectangle.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Point TopCenter
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the top-right point of the rectangle.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Point TopRight
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the bottom-right point of the rectangle.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Point BottomRight
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the bottom-left point of the rectangle.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Point BottomLeft
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the X-coordinate of the left edge.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public nfloat Left
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the Y-coordinate of the top edge.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public nfloat Top
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the X-coordinate of the right edge.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public nfloat Right
    {
        get
        {
        }
    }

    /// &lt;summary&gt;Returns the Y-coordinate of the bottom edge.&lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public nfloat Bottom
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns the center point of the rectangle.
    /// &lt;/summary&gt;
    public Point Center
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets or sets the size of the rectangle.
    /// &lt;/summary&gt;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public Size Size
    {
        get
        {
        }

        set
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns a new rectangle that is inset by the same amount on all four sides.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect Inset(nfloat inset)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if the specified &lt;paramref name = &quot;point&quot;/&gt; lies within this rectangle.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public bool Contains(Point point)
    {
    }

    /// &lt;summary&gt;
    /// Returns a rectangle expanded horizontally and vertically by the specified amounts.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect Expand(nfloat h, nfloat v)
    {
    }

    /// &lt;summary&gt;
    /// Returns a rectangle expanded uniformly in all directions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Rect Expand(nfloat expand)
    {
    }

    /// &lt;summary&gt;
    /// Implicit conversion from a 4-tuple to a rectangle.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Rect(ValueTuple&lt;nfloat, nfloat, nfloat, nfloat&gt; tuple)
    {
    }

    /// &lt;summary&gt;
    /// Returns a rectangle expanded outward by a &lt;see cref = &quot;Frame&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Rect operator +(Rect rect, Frame frame)
    {
    }

    /// &lt;summary&gt;
    /// Returns a rectangle inset inward by a &lt;see cref = &quot;Frame&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Rect operator -(Rect rect, Frame frame)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if two rectangles are equal in position and size.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator ==(Rect lhs, Rect rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if any of the rectangle fields are different.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator !=(Rect lhs, Rect rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override bool Equals(object? obj)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if this rectangle is equal to another rectangle in position and size.
    /// &lt;/summary&gt;
    public bool Equals(Rect other)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override int GetHashCode()
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override string ToString()
    {
    }
}
</code></pre>
<h3 id="math2dsizecs">Math2D/Size.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents a two-dimensional size with &lt;see cref = &quot;Width&quot;/&gt; and &lt;see cref = &quot;Height&quot;/&gt; components.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A &lt;see cref = &quot;Size&quot;/&gt; specifies how much space an element occupies, without defining its position.
/// It is commonly used in layout systems to describe constraints or measured results.
/// &lt;/remarks&gt;
public struct Size
{
    /// &lt;summary&gt;The width of the element.&lt;/summary&gt;
    public nfloat Width;
    /// &lt;summary&gt;The height of the element.&lt;/summary&gt;
    public nfloat Height;
    /// &lt;summary&gt;A size with zero width and height.&lt;/summary&gt;
    public static readonly Size Empty = new Size(0, 0);
    /// &lt;summary&gt;A size with infinite width and height.&lt;/summary&gt;
    public static readonly Size Infinity = new Size(nfloat.PositiveInfinity, nfloat.PositiveInfinity);
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;Size&quot;/&gt; struct with zero dimensions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Size()
    {
    }

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;Size&quot;/&gt; struct with the given width and height.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;width&quot;&gt;The width of the size.&lt;/param&gt;
    /// &lt;param name = &quot;height&quot;&gt;The height of the size.&lt;/param&gt;
    [DebuggerStepThrough]
    public Size(nfloat width, nfloat height)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple to a &lt;see cref = &quot;Size&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Size(ValueTuple&lt;nfloat, nfloat&gt; tuple)
    {
    }

    /// &lt;summary&gt;
    /// Explicitly converts a &lt;see cref = &quot;Vector&quot;/&gt; to a &lt;see cref = &quot;Size&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static explicit operator Size(Vector vector)
    {
    }

    /// &lt;summary&gt;
    /// Adds edge spacing from a &lt;see cref = &quot;Frame&quot;/&gt; to a &lt;see cref = &quot;Size&quot;/&gt;, increasing its dimensions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Size operator +(Size size, Frame frame)
    {
    }

    /// &lt;summary&gt;
    /// Subtracts edge spacing from a &lt;see cref = &quot;Size&quot;/&gt;, reducing its dimensions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Size operator -(Size size, Frame frame)
    {
    }

    /// &lt;summary&gt;
    /// Adds two sizes together component-wise.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Size operator +(Size lhs, Size rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override string ToString()
    {
    }

    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if the two sizes have the same dimensions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator ==(Size lhs, Size rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if the two sizes have different dimensions.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator !=(Size lhs, Size rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override bool Equals(object? obj)
    {
    }

    /// &lt;summary&gt;
    /// Returns &lt;c&gt;true&lt;/c&gt; if this size is equal to the specified &lt;paramref name = &quot;other&quot;/&gt;.
    /// &lt;/summary&gt;
    public bool Equals(Size other)
    {
    }

    /// &lt;inheritdoc/&gt;
    [DebuggerStepThrough]
    public override int GetHashCode()
    {
    }

    /// &lt;summary&gt;
    /// Returns the minimum of two sizes, using the smaller width and height from each.
    /// &lt;/summary&gt;
    public static Size Min(Size lhs, Size rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns the maximum of two sizes, using the larger width and height from each.
    /// &lt;/summary&gt;
    public static Size Max(Size lhs, Size rhs)
    {
    }
}
</code></pre>
<h3 id="math2dvectorcs">Math2D/Vector.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Math2D;
/// &lt;summary&gt;
/// Represents a 2D vector with X and Y components, commonly used for geometric operations,
/// layout math, and movement in 2D space.
/// &lt;/summary&gt;
public struct Vector
{
    /// &lt;summary&gt;The horizontal component of the vector.&lt;/summary&gt;
    public nfloat X;
    /// &lt;summary&gt;The vertical component of the vector.&lt;/summary&gt;
    public nfloat Y;
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref = &quot;Vector&quot;/&gt; struct
    /// with the specified X and Y components.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;x&quot;&gt;The horizontal component of the vector.&lt;/param&gt;
    /// &lt;param name = &quot;y&quot;&gt;The vertical component of the vector.&lt;/param&gt;
    [DebuggerStepThrough]
    public Vector(nfloat x, nfloat y)
    {
    }

    /// &lt;summary&gt;A zero vector (0, 0).&lt;/summary&gt;
    public static readonly Vector Zero = (0, 0);
    /// &lt;summary&gt;A unit vector (1, 1).&lt;/summary&gt;
    public static readonly Vector One = (1, 1);
    /// &lt;summary&gt;A unit vector pointing left (-1, 0).&lt;/summary&gt;
    public static readonly Vector Left = (-1, 0);
    /// &lt;summary&gt;A unit vector pointing up (0, -1).&lt;/summary&gt;
    public static readonly Vector Up = (0, -1);
    /// &lt;summary&gt;A unit vector pointing right (1, 0).&lt;/summary&gt;
    public static readonly Vector Right = (1, 0);
    /// &lt;summary&gt;A unit vector pointing down (0, 1).&lt;/summary&gt;
    public static readonly Vector Down = (0, 1);
    /// &lt;summary&gt;
    /// Returns a normalized (unit length) version of this vector.
    /// &lt;/summary&gt;
    public Vector Normalized
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns the magnitude (length) of the vector.
    /// &lt;/summary&gt;
    public nfloat Magnitude
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Rotates the vector counterclockwise by the given angle (in degrees).
    /// &lt;/summary&gt;
    public Vector Rotate(nfloat degrees)
    {
    }

    /// &lt;summary&gt;
    /// Returns the dot product of two vectors.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat Dot(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Projects &lt;paramref name = &quot;lhs&quot;/&gt; onto &lt;paramref name = &quot;rhs&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector Project(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns the 2D cross product (scalar) of two vectors.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat Cross(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns a new vector with its magnitude limited to the specified maximum.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public Vector Clamp(nfloat max)
    {
    }

    /// &lt;summary&gt;
    /// Returns the clockwise angle (in radians) from the upward direction (0, 1) to the given vector.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat Angle(Vector v)
    {
    }

    /// &lt;summary&gt;
    /// Returns a unit vector rotated clockwise from the upward direction (0, 1) by the given angle (in radians).
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector Angle(nfloat radians)
    {
    }

    /// &lt;summary&gt;
    /// Returns the signed angle (in radians) from &lt;paramref name = &quot;lhs&quot;/&gt; to &lt;paramref name = &quot;rhs&quot;/&gt;, clockwise from upward.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static nfloat Angle(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Linearly interpolates between two vectors by &lt;paramref name = &quot;step&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector Lerp(Vector start, Vector end, nfloat step)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a &lt;see cref = &quot;Point&quot;/&gt; to a &lt;see cref = &quot;Vector&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Vector(Point point)
    {
    }

    /// &lt;summary&gt;
    /// Multiplies a vector by a scalar.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator *(Vector v, nfloat f)
    {
    }

    /// &lt;summary&gt;
    /// Divides a vector by a scalar.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator /(Vector v, nfloat f)
    {
    }

    /// &lt;summary&gt;
    /// Multiplies a scalar by a vector.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator *(nfloat f, Vector v)
    {
    }

    /// &lt;summary&gt;
    /// Adds two vectors.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator +(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Subtracts one vector from another.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static Vector operator -(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Implicitly converts a tuple to a &lt;see cref = &quot;Vector&quot;/&gt;.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static implicit operator Vector(ValueTuple&lt;nfloat, nfloat&gt; tuple)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if the two vectors have equal components.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator ==(Vector lhs, Vector rhs)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if any component of the two vectors is different.
    /// &lt;/summary&gt;
    [DebuggerStepThrough]
    public static bool operator !=(Vector lhs, Vector rhs)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override bool Equals(object? obj)
    {
    }

    /// &lt;summary&gt;
    /// Returns true if this vector is equal to another vector.
    /// &lt;/summary&gt;
    public bool Equals(Vector other)
    {
    }

    /// &lt;inheritdoc/&gt;
    public override int GetHashCode()
    {
    }

    /// &lt;inheritdoc/&gt;
    public override string ToString()
    {
    }
}
</code></pre>
<h3 id="objdebugnet90netcoreappversionv90assemblyattributescs">obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs</h3>
<pre><code class="lang-csharp">// &lt;autogenerated /&gt;
using System;
using System.Reflection;

[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(&quot;.NETCoreApp,Version=v9.0&quot;, FrameworkDisplayName = &quot;.NET 9.0&quot;)]
</code></pre>
<h3 id="setemptysetcs">Set/EmptySet.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Set;
/// &lt;summary&gt;
/// Represents an empty set — a set that contains no elements.
/// &lt;/summary&gt;
/// &lt;typeparam name = &quot;T&quot;&gt;The type of elements the set could (but does not) contain.&lt;/typeparam&gt;
/// &lt;remarks&gt;
/// This type always returns &lt;c&gt;false&lt;/c&gt; from &lt;see cref = &quot;Contains&quot;/&gt;. It is a useful identity for 
/// set composition and for scenarios like default hit test areas or disabled regions.
/// &lt;/remarks&gt;
public sealed class EmptySet&lt;T&gt; : INonEnumerableSet&lt;T&gt;
{
    /// &lt;summary&gt;
    /// A shared singleton instance of the empty set.
    /// &lt;/summary&gt;
    public static readonly EmptySet&lt;T&gt; Instance = new();
    // Private constructor to enforce singleton usage.
    private EmptySet()
    {
    }

    /// &lt;summary&gt;
    /// Always returns &lt;c&gt;false&lt;/c&gt;, since no element belongs to the empty set.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;obj&quot;&gt;The object to test.&lt;/param&gt;
    /// &lt;returns&gt;&lt;c&gt;false&lt;/c&gt; for all inputs.&lt;/returns&gt;
    public bool Contains(T obj)
    {
    }
}
</code></pre>
<h3 id="setinonenumerablesetcs">Set/INonEnumerableSet.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.Set;
/// &lt;summary&gt;
/// Represents a mathematical set as defined by its membership test: 
/// whether an element belongs to the set.
/// &lt;/summary&gt;
/// &lt;typeparam name = &quot;T&quot;&gt;The type of elements being tested for membership.&lt;/typeparam&gt;
/// &lt;remarks&gt;
/// This interface does not imply enumeration, mutation, or collection semantics. 
/// It aligns with the pure set-theoretic notion where a set is characterized solely 
/// by the ability to determine if a value is a member of the set (i.e., &lt;c&gt;x ∈ S&lt;/c&gt;).
/// &lt;/remarks&gt;
public interface INonEnumerableSet&lt;T&gt;
{
    /// &lt;summary&gt;
    /// Determines whether the specified element is a member of this set.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;obj&quot;&gt;The element to test for membership.&lt;/param&gt;
    /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the element belongs to the set; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
    public bool Contains(T obj);
}
</code></pre>
<h3 id="uidirectioncs">UI/Direction.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Indicates the semantic inline direction of content, such as left-to-right or right-to-left.
/// Used to resolve text alignment, layout flow, and mirroring behavior.
/// &lt;/summary&gt;
public enum Direction : byte
{
    /// &lt;summary&gt;
    /// Inherit direction from the parent view.
    /// &lt;/summary&gt;
    Inherit = 0,
    /// &lt;summary&gt;
    /// Left-to-right flow (default for Western languages).
    /// &lt;/summary&gt;
    LeftToRight = 1,
    /// &lt;summary&gt;
    /// Right-to-left flow (used in Arabic, Hebrew, etc).
    /// &lt;/summary&gt;
    RightToLeft = 2
}
</code></pre>
<h3 id="uiflowcs">UI/Flow.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Controls whether layout and rendering should respect directionality and writing mode.
/// Used to suppress mirroring and bidi-aware behavior for diagrams, graphs, and non-linguistic views.
/// &lt;/summary&gt;
public enum Flow : byte
{
    /// &lt;summary&gt;
    /// Inherit flow behavior from the parent view.
    /// &lt;/summary&gt;
    Inherit = 0,
    /// &lt;summary&gt;
    /// Enable direction-aware and writing-mode-aware behavior.
    /// &lt;/summary&gt;
    Aware = 1,
    /// &lt;summary&gt;
    /// Disable all direction-aware layout and rendering. Used for charts, maps, etc.
    /// &lt;/summary&gt;
    Unaware = 2
}
</code></pre>
<h3 id="uiflowdirectioncs">UI/FlowDirection.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Represents the resolved physical direction of layout flow along an axis.
/// This is derived from &lt;see cref = &quot;WritingMode&quot;/&gt; and &lt;see cref = &quot;Direction&quot;/&gt;,
/// and is used to control stacking, alignment, and layout flow along block or inline axes.
/// &lt;/summary&gt;
public enum FlowDirection : byte
{
    /// &lt;summary&gt;
    /// Content flows from left to right.
    /// &lt;/summary&gt;
    LeftToRight = 0,
    /// &lt;summary&gt;
    /// Content flows from right to left.
    /// &lt;/summary&gt;
    RightToLeft = 1,
    /// &lt;summary&gt;
    /// Content flows from top to bottom.
    /// &lt;/summary&gt;
    TopToBottom = 2,
    /// &lt;summary&gt;
    /// Content flows from bottom to top.
    /// &lt;/summary&gt;
    BottomToTop = 3
}
</code></pre>
<h3 id="uihorizontalalignmentcs">UI/HorizontalAlignment.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Specifies how a view should be aligned horizontally within its layout bounds.
/// Used by parent containers during layout to position the view along the inline axis.
/// &lt;/summary&gt;
public enum HorizontalAlignment : byte
{
    /// &lt;summary&gt;
    /// Stretch to fill the full available horizontal space.
    /// &lt;/summary&gt;
    Stretch = 0,
    /// &lt;summary&gt;
    /// Align to the left edge (or start edge in LTR layouts).
    /// &lt;/summary&gt;
    Left = 1,
    /// &lt;summary&gt;
    /// Center horizontally within the available space.
    /// &lt;/summary&gt;
    Center = 2,
    /// &lt;summary&gt;
    /// Align to the right edge (or start edge in RTL layouts).
    /// &lt;/summary&gt;
    Right = 3
}
</code></pre>
<h3 id="uihorizontalstackcs">UI/HorizontalStack.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// A layout container that arranges its children horizontally from left to right.
/// 
/// Each child is measured with unconstrained width and a constrained height.
/// The container expands to fit the combined width of all children.
/// &lt;/summary&gt;
public class HorizontalStack : ViewCollection
{
    /// &lt;inheritdoc/&gt;
    protected override Size MeasureCore(Size availableBorderEdgeSize)
    {
    }

    /// &lt;inheritdoc/&gt;
    protected override void ArrangeCore(Rect rect)
    {
    }
}
</code></pre>
<h3 id="uihorizontaluniformstackcs">UI/HorizontalUniformStack.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// A layout container that arranges its children in a horizontal stack,
/// assigning each child the same width.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// &lt;para&gt;
/// If the parent provides a constrained width, the container divides
/// the available width equally among all children.
/// &lt;/para&gt;
/// &lt;para&gt;
/// If the width is unconstrained (infinite), the container measures each child
/// to determine the maximum width, and assigns that uniform width to all columns.
/// &lt;/para&gt;
/// &lt;para&gt;
/// The height of the container is based on the tallest child.
/// &lt;/para&gt;
/// &lt;/remarks&gt;
public class HorizontalUniformStack : ViewCollection
{
    /// &lt;summary&gt;
    /// Measures the desired size of this layout container and its children,
    /// based on the available space provided by the parent.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;availableBorderEdgeSize&quot;&gt;
    /// The space available for layout, excluding padding and borders.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// The desired size of this container based on its layout strategy.
    /// &lt;/returns&gt;
    protected override Size MeasureCore(Size availableBorderEdgeSize)
    {
    }

    /// &lt;summary&gt;
    /// Arranges the children into horizontally stacked columns of equal width.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;
    /// The rectangle within which to arrange children.
    /// &lt;/param&gt;
    protected override void ArrangeCore(Rect rect)
    {
    }
}
</code></pre>
<h3 id="uilayoutguidecs">UI/LayoutGuide.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Canvas;
using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Encapsulates the parameters and results of a layout pass (Measure, Arrange, Render) for a view.
/// &lt;/summary&gt;
public struct LayoutGuide
{
    /// &lt;summary&gt;
    /// Indicates the type of layout pass being performed: Measure, Arrange, or Render.
    /// &lt;/summary&gt;
    public LayoutPass Pass;
    // Measure spec
    /// &lt;summary&gt;
    /// The available space for measuring this view's margin box. Used during the Measure pass.
    /// &lt;/summary&gt;
    public Size AvailableSize;
    /// &lt;summary&gt;
    /// How the view should size itself horizontally during measurement (exact or at-most).
    /// &lt;/summary&gt;
    public SizeTo XSize;
    /// &lt;summary&gt;
    /// How the view should size itself vertically during measurement (exact or at-most).
    /// &lt;/summary&gt;
    public SizeTo YSize;
    /// &lt;summary&gt;
    /// Optional context for measuring text content during the Measure pass.
    /// &lt;/summary&gt;
    public ITextMeasureContext? MeasureContext;
    /// &lt;summary&gt;
    /// The desired size of the view's margin box, produced during the Measure pass.
    /// &lt;/summary&gt;
    public Size DesiredSize;
    // Arrange spec
    /// &lt;summary&gt;
    /// The anchor point that defines the alignment constraint for layout.
    /// This point serves as a reference for positioning the view based on alignment.
    /// For example, if alignment is set to &lt;see cref = &quot;Align.End&quot;/&gt;, the anchor represents the bottom-right constraint.
    /// If alignment is &lt;see cref = &quot;Align.Start&quot;/&gt;, it represents the top-left constraint.
    /// &lt;/summary&gt;
    public Point Anchor;
    /// &lt;summary&gt;
    /// The horizontal alignment of the view within its allocated space.
    /// &lt;/summary&gt;
    public Align XAlign;
    /// &lt;summary&gt;
    /// The vertical alignment of the view within its allocated space.
    /// &lt;/summary&gt;
    public Align YAlign;
    /// &lt;summary&gt;
    /// The final rectangle occupied by the view's border edge box after the Arrange pass.
    /// &lt;/summary&gt;
    public Rect ArrangedRect;
    // Render spec
    /// &lt;summary&gt;
    /// Optional rendering context for drawing during the Render pass.
    /// &lt;/summary&gt;
    public IContext? RenderContext;
    /// &lt;summary&gt;
    /// Returns true if this guide represents a Measure pass.
    /// &lt;/summary&gt;
    public bool IsMeasure
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns true if this guide represents an Arrange pass.
    /// &lt;/summary&gt;
    public bool IsArrange
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Returns true if this guide represents a Render pass.
    /// &lt;/summary&gt;
    public bool IsRender
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Flags indicating which type of layout pass is being performed.
    /// Multiple passes may be combined (e.g., Measure | Render).
    /// &lt;/summary&gt;
    [Flags]
    public enum LayoutPass : byte
    {
        /// &lt;summary&gt;
        /// Indicates a Measure pass to determine desired size.
        /// &lt;/summary&gt;
        Measure = 1 &lt;&lt; 0,
        /// &lt;summary&gt;
        /// Indicates an Arrange pass to finalize layout position and size.
        /// &lt;/summary&gt;
        Arrange = 1 &lt;&lt; 1,
        /// &lt;summary&gt;
        /// Indicates a Render pass to draw the view's content.
        /// &lt;/summary&gt;
        Render = 1 &lt;&lt; 2,
    }

    /// &lt;summary&gt;
    /// Defines how the view should interpret the size constraints during measurement.
    /// &lt;/summary&gt;
    public enum SizeTo : byte
    {
        /// &lt;summary&gt;
        /// The view must exactly match the given size constraints.
        /// &lt;/summary&gt;
        Exact,
        /// &lt;summary&gt;
        /// The view may size to its content, but must not exceed the given constraints.
        /// &lt;/summary&gt;
        AtMost
    }

    /// &lt;summary&gt;
    /// Defines alignment of a view within a layout axis.
    /// &lt;/summary&gt;
    public enum Align : byte
    {
        /// &lt;summary&gt;
        /// Align to the start (top or left).
        /// &lt;/summary&gt;
        Start = 0,
        /// &lt;summary&gt;
        /// Align to the center.
        /// &lt;/summary&gt;
        Center = 1,
        /// &lt;summary&gt;
        /// Align to the end (bottom or right).
        /// &lt;/summary&gt;
        End = 2
    }
}
</code></pre>
<h3 id="uiverticalalignmentcs">UI/VerticalAlignment.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Specifies how a view should be aligned vertically within its layout bounds.
/// Used by parent containers to control vertical positioning along the block axis.
/// &lt;/summary&gt;
public enum VerticalAlignment : byte
{
    /// &lt;summary&gt;
    /// Stretch to fill the full available vertical space.
    /// &lt;/summary&gt;
    Stretch = 0,
    /// &lt;summary&gt;
    /// Align to the top edge (or start edge in top-down layouts).
    /// &lt;/summary&gt;
    Top = 1,
    /// &lt;summary&gt;
    /// Center vertically within the available space.
    /// &lt;/summary&gt;
    Middle = 2,
    /// &lt;summary&gt;
    /// Align to the bottom edge (or start edge in bottom-up layouts).
    /// &lt;/summary&gt;
    Bottom = 3
}
</code></pre>
<h3 id="uiverticalstackcs">UI/VerticalStack.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// A layout container that arranges its children vertically from top to bottom.
/// 
/// Each child is measured with an unconstrained height and is allowed to take up as much vertical space as needed.
/// The container expands to fit the combined height of all children.
/// &lt;/summary&gt;
public class VerticalStack : ViewCollection
{
    /// &lt;inheritdoc/&gt;
    protected override Size MeasureCore(Size availableBorderEdgeSize)
    {
    }

    /// &lt;inheritdoc/&gt;
    protected override void ArrangeCore(Rect rect)
    {
    }
}
</code></pre>
<h3 id="uiverticaluniformstackcs">UI/VerticalUniformStack.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// A layout container that arranges its children in a vertical stack,
/// giving each child the same height.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// &lt;para&gt;
/// If the parent provides a constrained height, the container divides
/// the available height equally among all children.
/// &lt;/para&gt;
/// &lt;para&gt;
/// If the height is unconstrained (infinite), the container measures each child
/// to determine the maximum height, and uses that height for all rows.
/// &lt;/para&gt;
/// &lt;/remarks&gt;
public class VerticalUniformStack : ViewCollection
{
    /// &lt;summary&gt;
    /// Measures the desired size of this layout container and its children,
    /// based on the available space provided by the parent.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;availableBorderEdgeSize&quot;&gt;The space available for layout, excluding padding and borders.&lt;/param&gt;
    /// &lt;returns&gt;The desired size of this container based on its layout strategy.&lt;/returns&gt;
    protected override Size MeasureCore(Size availableBorderEdgeSize)
    {
    }

    /// &lt;summary&gt;
    /// Arranges the children into vertically stacked rows of equal height.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle within which to arrange children.&lt;/param&gt;
    protected override void ArrangeCore(Rect rect)
    {
    }
}
</code></pre>
<h3 id="uiviewcs">UI/View.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Canvas;
using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Base class for all UI elements in the Xui layout engine.
/// A view participates in layout, rendering, and input hit testing, and may contain child views.
/// &lt;/summary&gt;
public abstract class View
{
    /// &lt;summary&gt;
    /// The parent view in the visual hierarchy. This is set automatically when the view is added to a container.
    /// &lt;/summary&gt;
    public View? Parent { get; internal set; }
    /// &lt;summary&gt;
    /// The border edge of this view in global coordinates relative to the top-left of the window.
    /// &lt;/summary&gt;
    public Rect Frame { get; protected set; }
    /// &lt;summary&gt;
    /// The margin around this view. Margins participate in collapsed margin logic during layout,
    /// and are external spacing relative to the parent or surrounding siblings.
    /// &lt;/summary&gt;
    public Frame Margin { get; set; } = (0, 0);
    /// &lt;summary&gt;
    /// The horizontal alignment of this view inside its layout anchor region.
    /// Used during layout when the view has remaining space within its container.
    /// &lt;/summary&gt;
    public HorizontalAlignment HorizontalAlignment { get; set; } = HorizontalAlignment.Stretch;
    /// &lt;summary&gt;
    /// The vertical alignment of this view inside its layout anchor region.
    /// Used during layout when the view has remaining space within its container.
    /// &lt;/summary&gt;
    public VerticalAlignment VerticalAlignment { get; set; } = VerticalAlignment.Stretch;
    /// &lt;summary&gt;
    /// The writing direction of this view, which determines the block or inline flow direction.
    /// Inherited from the parent flow context if set to &lt;see cref = &quot;Direction.Inherit&quot;/&gt;.
    /// &lt;/summary&gt;
    public Direction Direction { get; set; } = Direction.Inherit;
    /// &lt;summary&gt;
    /// The writing mode of this view (e.g. horizontal top-to-bottom or vertical right-to-left).
    /// Inherited from the parent if set to &lt;see cref = &quot;WritingMode.Inherit&quot;/&gt;.
    /// &lt;/summary&gt;
    public WritingMode WritingMode { get; set; } = WritingMode.HorizontalTB;
    /// &lt;summary&gt;
    /// Controls how the layout system treats this view's children.
    /// Can be inherited or explicitly overridden for advanced layout containers.
    /// &lt;/summary&gt;
    public Flow Flow { get; set; } = Flow.Aware;
    /// &lt;summary&gt;
    /// The minimum width of the border edge box.
    /// &lt;/summary&gt;
    public nfloat MinimumWidth { get; set; } = 0;
    /// &lt;summary&gt;
    /// The minimum height of the border edge box.
    /// &lt;/summary&gt;
    public nfloat MinimumHeight { get; set; } = 0;
    /// &lt;summary&gt;
    /// The maximum width of the border edge box.
    /// &lt;/summary&gt;
    public nfloat MaximumWidth { get; set; } = nfloat.PositiveInfinity;
    /// &lt;summary&gt;
    /// The maximum height of the border edge box.
    /// &lt;/summary&gt;
    public nfloat MaximumHeight { get; set; } = nfloat.PositiveInfinity;
    /// &lt;summary&gt;
    /// Returns the number of child views. Used by layout containers and traversal logic.
    /// Leaf views should return 0.
    /// &lt;/summary&gt;
    public virtual int Count { get; } = 0;

    /// &lt;summary&gt;
    /// Indexer to access child views by index.
    /// Layout containers should implement this to expose their children.
    /// &lt;/summary&gt;
    public virtual View this[int index]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Determines whether the given point (in local coordinates) hits this view’s visual bounds.
    /// Used for input dispatch and hit testing.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;point&quot;&gt;The point to test, relative to this view’s coordinate space.&lt;/param&gt;
    /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the point is inside the view’s frame; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
    public virtual bool HitTest(Point point)
    {
    }

    /// &lt;summary&gt;
    /// Performs a full layout pass for a view - measure, arrange and render.
    /// 
    /// Flags can limit to a subset of the layout passes, in case a container needs to measure children multiple times,
    /// or in case a container can rush forward without forking the layout pass into multiple sub-passes.
    /// 
    /// The layout method will delegate parts of the execution to &lt;see cref = &quot;MeasureCore&quot;/&gt;, &lt;see cref = &quot;ArrangeCore&quot;/&gt; and &lt;see cref = &quot;RenderCore&quot;/&gt;.
    /// 
    /// If a container needs to call multiple times methods for a child,
    /// either call the &lt;see cref = &quot;Measure&quot;/&gt;, &lt;see cref = &quot;Arrange&quot;/&gt; and &lt;see cref = &quot;Render&quot;/&gt;,
    /// or construct a &lt;see cref = &quot;LayoutGuide&quot;/&gt; with the specific flags and pass it to &lt;see cref = &quot;Update&quot;/&gt;.
    /// 
    /// Some containers may override and implement a Layout in a way, that it compacts the flow and avoids fork,
    /// like a VerticalStack that is placed on fullscreen (with fixed width),
    /// can arrange children top to bottom calling their Layout directly - eventually going foreach-layout without splitting into foreach-measure, foreach-arrange cycles.
    /// VerticalStack however, when centered, while it can layout children vertically in a single pass, it can't render, because it needs its height to figure out its position,
    /// so in these cases it may foreach-layout (measure and arrange) resolve the stack Y position and then foreach-layout (for render).
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;guide&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual LayoutGuide Update(LayoutGuide guide)
    {
    }

    /// &lt;summary&gt;
    /// Measures the view using the specified available size, returning the desired size
    /// calculated during the layout pass.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;availableSize&quot;&gt;The maximum space available for the view to occupy.&lt;/param&gt;
    /// &lt;returns&gt;The size that the view desires to occupy within the constraints.&lt;/returns&gt;
    public Size Measure(Size availableSize)
    {
    }

    /// &lt;summary&gt;
    /// Arranges the view within the specified rectangle, finalizing its layout position and size.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;The rectangle defining the position and exact size for the view.&lt;/param&gt;
    /// &lt;returns&gt;The rectangle occupied by the arranged view.&lt;/returns&gt;
    public Rect Arrange(Rect rect)
    {
    }

    /// &lt;summary&gt;
    /// Renders the view using the given rendering context. This should be called after layout is complete.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;context&quot;&gt;The rendering context used to draw the view.&lt;/param&gt;
    public void Render(IContext context)
    {
    }

    /// &lt;summary&gt;
    /// Determines the minimum size that this view's border edge box requires,
    /// given the maximum available size. Margin is not part of this size.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;availableBorderEdgeSize&quot;&gt;
    /// The maximum size available for the view’s border edge box. 
    /// This size excludes margins, which are handled by the parent layout.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// The desired size of the border edge box based on content and layout logic.
    /// &lt;/returns&gt;
    protected virtual Size MeasureCore(Size availableBorderEdgeSize)
    {
    }

    /// &lt;summary&gt;
    /// Performs the layout pass by arranging content and children within the view's
    /// border edge box, using the provided rectangle.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;rect&quot;&gt;
    /// The final rectangle (position and size) allocated to this view's border edge box.
    /// &lt;/param&gt;
    protected virtual void ArrangeCore(Rect rect)
    {
    }

    /// &lt;summary&gt;
    /// Renders the content and children of this view using the provided rendering context.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;context&quot;&gt;
    /// The drawing context used for rendering visual content to the output surface.
    /// &lt;/param&gt;
    protected virtual void RenderCore(IContext context)
    {
    }
}
</code></pre>
<h3 id="uiviewcollectioncs">UI/ViewCollection.cs</h3>
<pre><code class="lang-csharp">using Xui.Core.Canvas;
using Xui.Core.Math2D;

namespace Xui.Core.UI;
/// &lt;summary&gt;
/// A base class for container views that hold and manage a list of child views.
/// Provides methods for adding, removing, rendering, and hit testing children.
/// &lt;/summary&gt;
public abstract class ViewCollection : View
{
    /// &lt;summary&gt;
    /// The internal list of child views contained within this view.
    /// &lt;/summary&gt;
    protected readonly List&lt;View&gt; children = new();
    /// &lt;summary&gt;
    /// Gets the number of child views in this collection.
    /// &lt;/summary&gt;
    public override int Count
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Gets the child view at the specified index.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;index&quot;&gt;The index of the child to retrieve.&lt;/param&gt;
    /// &lt;returns&gt;The child view at the given index.&lt;/returns&gt;
    public override View this[int index]
    {
        get
        {
        }
    }

    /// &lt;summary&gt;
    /// Adds the provided views to this container during object initialization.
    /// This property is intended for use with C# object initializers and will not clear existing children.
    /// &lt;/summary&gt;
    public ReadOnlySpan&lt;View&gt; Content
    {
        init
        {
        }
    }

    /// &lt;summary&gt;
    /// Adds a view to this container.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;child&quot;&gt;The view to add.&lt;/param&gt;
    /// &lt;exception cref = &quot;InvalidOperationException&quot;&gt;Thrown if the view already has a parent.&lt;/exception&gt;
    public virtual void Add(View child)
    {
    }

    /// &lt;summary&gt;
    /// Removes a view from this container.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;child&quot;&gt;The view to remove.&lt;/param&gt;
    public virtual void Remove(View child)
    {
    }

    /// &lt;summary&gt;
    /// Renders all child views using the provided rendering context.
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;context&quot;&gt;The rendering context used for drawing visual content.&lt;/param&gt;
    protected override void RenderCore(IContext context)
    {
    }

    /// &lt;summary&gt;
    /// Performs hit testing against the child views in reverse order (top-most first).
    /// &lt;/summary&gt;
    /// &lt;param name = &quot;point&quot;&gt;The point to test, in the coordinate space of this view.&lt;/param&gt;
    /// &lt;returns&gt;True if any child was hit; otherwise, falls back to base implementation.&lt;/returns&gt;
    public override bool HitTest(Point point)
    {
    }
}
</code></pre>
<h3 id="uiwritingmodecs">UI/WritingMode.cs</h3>
<pre><code class="lang-csharp">namespace Xui.Core.UI;
/// &lt;summary&gt;
/// Specifies the orientation and flow direction of text and block layout.
/// Affects which axis is considered &quot;block&quot; and &quot;inline&quot;.
/// &lt;/summary&gt;
public enum WritingMode : byte
{
    /// &lt;summary&gt;
    /// Inherit direction from the parent view.
    /// &lt;/summary&gt;
    Inherit,
    /// &lt;summary&gt;
    /// Horizontal writing mode. Text flows left-to-right, lines stack top-to-bottom.
    /// &lt;/summary&gt;
    HorizontalTB,
    /// &lt;summary&gt;
    /// Vertical writing mode. Lines stack right-to-left, text flows top-to-bottom.
    /// &lt;/summary&gt;
    VerticalRL,
    /// &lt;summary&gt;
    /// Vertical writing mode. Lines stack left-to-right, text flows top-to-bottom.
    /// &lt;/summary&gt;
    VerticalLR,
    /// &lt;summary&gt;
    /// Sideways vertical mode. Lines stack right-to-left, but glyphs are rotated to remain horizontal.
    /// &lt;/summary&gt;
    SidewaysRL,
    /// &lt;summary&gt;
    /// Sideways vertical mode. Lines stack left-to-right, with horizontal glyph orientation.
    /// &lt;/summary&gt;
    SidewaysLR
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/xuiapps/code/blob/main/www/ai/ai-api-ref.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
